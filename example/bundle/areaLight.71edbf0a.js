function t(t,e,n,a){Object.defineProperty(t,e,{get:n,set:a,enumerable:!0,configurable:!0})}var e="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{},n={},a={},r=e.parcelRequire5b70;null==r&&((r=function(t){if(t in n)return n[t].exports;if(t in a){var e=a[t];delete a[t];var r={id:t,exports:{}};return n[t]=r,e.call(r.exports,r,r.exports),r.exports}var i=new Error("Cannot find module '"+t+"'");throw i.code="MODULE_NOT_FOUND",i}).register=function(t,e){a[t]=e},e.parcelRequire5b70=r),r.register("4CEV9",(function(e,n){t(e.exports,"PathTracingRenderer",(()=>r("hWds8").PathTracingRenderer)),t(e.exports,"DynamicPathTracingSceneGenerator",(()=>r("lDKrr").DynamicPathTracingSceneGenerator)),t(e.exports,"MaterialReducer",(()=>r("62xhu").MaterialReducer)),t(e.exports,"PhysicalCamera",(()=>r("csrdQ").PhysicalCamera)),t(e.exports,"EquirectCamera",(()=>r("1uEwp").EquirectCamera)),t(e.exports,"BlurredEnvMapGenerator",(()=>r("eLX8K").BlurredEnvMapGenerator)),t(e.exports,"PhysicalPathTracingMaterial",(()=>r("9dwDm").PhysicalPathTracingMaterial)),r("hWds8"),r("lDKrr"),r("62xhu"),r("csrdQ"),r("1uEwp"),r("eLX8K"),r("9dwDm")})),r.register("hWds8",(function(e,n){t(e.exports,"PathTracingRenderer",(()=>c));var a=r("ilwiq"),i=r("RPVlj"),o=r("2JSgM");function*s(){const{_renderer:t,_fsQuad:e,_blendQuad:n,_primaryTarget:r,_blendTargets:i,alpha:o,camera:s,material:l}=this,c=n.material;let[h,u]=i;for(;;){o?(c.opacity=1/(this.samples+1),l.blending=a.NoBlending,l.opacity=1):(l.opacity=1/(this.samples+1),l.blending=a.NormalBlending);const i=r.width,f=r.height;l.resolution.set(i,f),l.seed++;const m=this.tiles.x||1,d=this.tiles.y||1,p=m*d,g=1/t.getPixelRatio();for(let a=0;a<d;a++)for(let v=0;v<m;v++){l.cameraWorldMatrix.copy(s.matrixWorld),l.invProjectionMatrix.copy(s.projectionMatrixInverse);let y=0;s.projectionMatrix.elements[15]>0&&(y=1),s.isEquirectCamera&&(y=2),l.setDefine("CAMERA_TYPE",y);const w=t.getRenderTarget(),b=t.autoClear;t.setRenderTarget(r),t.setScissorTest(!0),t.setScissor(g*Math.ceil(v*i/m),g*Math.ceil((d-a-1)*f/d),g*Math.ceil(i/m),g*Math.ceil(f/d)),t.autoClear=!1,e.render(t),t.setScissorTest(!1),t.setRenderTarget(w),t.autoClear=b,o&&(c.target1=h.texture,c.target2=r.texture,t.setRenderTarget(u),n.render(t),t.setRenderTarget(w)),this.samples+=1/p,yield}[h,u]=[u,h],this.samples=Math.round(this.samples)}}const l=new a.Color;class c{get material(){return this._fsQuad.material}set material(t){this._fsQuad.material=t}get target(){return this._alpha?this._blendTargets[1]:this._primaryTarget}set alpha(t){t||(this._blendTargets[0].dispose(),this._blendTargets[1].dispose()),this._alpha=t,this.reset()}get alpha(){return this._alpha}constructor(t){this.camera=null,this.tiles=new a.Vector2(1,1),this.samples=0,this.stableNoise=!1,this._renderer=t,this._alpha=!1,this._fsQuad=new i.FullScreenQuad(null),this._blendQuad=new i.FullScreenQuad(new o.BlendMaterial),this._task=null,this._primaryTarget=new a.WebGLRenderTarget(1,1,{format:a.RGBAFormat,type:a.FloatType}),this._blendTargets=[new a.WebGLRenderTarget(1,1,{format:a.RGBAFormat,type:a.FloatType}),new a.WebGLRenderTarget(1,1,{format:a.RGBAFormat,type:a.FloatType})]}setSize(t,e){this._primaryTarget.setSize(t,e),this._blendTargets[0].setSize(t,e),this._blendTargets[1].setSize(t,e),this.reset()}dispose(){this._primaryTarget.dispose(),this._blendTargets[0].dispose(),this._blendTargets[1].dispose(),this._fsQuad.dispose(),this._blendQuad.dispose(),this._task=null}reset(){const{_renderer:t,_primaryTarget:e,_blendTargets:n}=this,a=t.getRenderTarget(),r=t.getClearAlpha();t.getClearColor(l),t.setRenderTarget(e),t.setClearColor(0,0),t.clearColor(),t.setRenderTarget(n[0]),t.setClearColor(0,0),t.clearColor(),t.setRenderTarget(n[1]),t.setClearColor(0,0),t.clearColor(),t.setClearColor(l,r),t.setRenderTarget(a),this.samples=0,this._task=null,this.stableNoise&&(this.material.seed=0)}update(){this._task||(this._task=s.call(this)),this._task.next()}}})),r.register("2JSgM",(function(e,n){t(e.exports,"BlendMaterial",(()=>o));var a=r("ilwiq"),i=r("9fZ6X");class o extends i.MaterialBase{constructor(t){super({blending:a.NoBlending,uniforms:{target1:{value:null},target2:{value:null},opacity:{value:1}},vertexShader:"\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}",fragmentShader:"\n\n\t\t\t\tuniform float opacity;\n\n\t\t\t\tuniform sampler2D target1;\n\t\t\t\tuniform sampler2D target2;\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 color1 = texture2D( target1, vUv );\n\t\t\t\t\tvec4 color2 = texture2D( target2, vUv );\n\n\t\t\t\t\tfloat invOpacity = 1.0 - opacity;\n\t\t\t\t\tfloat totalAlpha = color1.a * invOpacity + color2.a * opacity;\n\n\t\t\t\t\tif ( color1.a != 0.0 || color2.a != 0.0 ) {\n\n\t\t\t\t\t\tgl_FragColor.rgb = color1.rgb * ( invOpacity * color1.a / totalAlpha ) + color2.rgb * ( opacity * color2.a / totalAlpha );\n\t\t\t\t\t\tgl_FragColor.a = totalAlpha;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl_FragColor = vec4( 0.0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}"}),this.setValues(t)}}})),r.register("lDKrr",(function(e,n){t(e.exports,"DynamicPathTracingSceneGenerator",(()=>s));var a=r("ilwiq"),i=r("8Zfx2"),o=r("jM3IF");class s{get initialized(){return Boolean(this.bvh)}constructor(t){this.objects=Array.isArray(t)?t:[t],this.bvh=null,this.geometry=new a.BufferGeometry,this.materials=null,this.textures=null,this.staticGeometryGenerator=new i.StaticGeometryGenerator(t)}reset(){this.bvh=null,this.geometry.dispose(),this.geometry=new a.BufferGeometry,this.materials=null,this.textures=null,this.staticGeometryGenerator=new i.StaticGeometryGenerator(this.objects)}dispose(){}generate(){const{objects:t,staticGeometryGenerator:e,geometry:n}=this;if(null===this.bvh){const a=["position","normal","tangent","uv"];for(let e=0,n=t.length;e<n;e++)t[e].traverse((t=>{if(t.isMesh){const e=!!t.material.normalMap;o.setCommonAttributes(t.geometry,{attributes:a,normalMapRequired:e})}}));const r=new Set,s=e.getMaterials();s.forEach((t=>{for(const e in t){const n=t[e];n&&n.isTexture&&r.add(n)}})),e.attributes=a,e.generate(n);const l=o.getGroupMaterialIndicesAttribute(n,s,s);return n.setAttribute("materialIndex",l),n.clearGroups(),this.bvh=new i.MeshBVH(n),this.materials=s,this.textures=Array.from(r),{bvh:this.bvh,materials:this.materials,textures:this.textures,objects:t}}{const{bvh:a}=this;return e.generate(n),a.refit(),{bvh:this.bvh,materials:this.materials,textures:this.textures,objects:t}}}}})),r.register("62xhu",(function(e,n){function a(t){return t.buffer instanceof ArrayBuffer&&"BYTES_PER_ELEMENT"in t}t(e.exports,"MaterialReducer",(()=>r));class r{constructor(){const t=new Set;t.add("uuid"),this.ignoreKeys=t,this.shareTextures=!0,this.textures=[],this.materials=[]}areEqual(t,e){const n=new Set,r=new Set,i=this.ignoreKeys,o=(t,e)=>{if(t===e)return!0;if(t&&e&&t instanceof Object&&e instanceof Object){if(r.has(t)||r.has(e))throw new Error("MaterialReducer: Material is recursive.");const s=t instanceof Element,l=e instanceof Element;if(s||l)return s===l&&t instanceof Image&&e instanceof Image&&t.src===e.src;const c=t instanceof ImageBitmap,h=e instanceof ImageBitmap;if(c||h)return!1;if(t.equals)return t.equals(e);const u=a(t),f=a(e);if(u||f){if(u!==f||t.constructor!==e.constructor||t.length!==e.length)return!1;for(let n=0,a=t.length;n<a;n++)if(t[n]!==e[n])return!1;return!0}r.add(t),r.add(e),n.clear();for(const e in t)!t.hasOwnProperty(e)||t[e]instanceof Function||i.has(e)||n.add(e);for(const t in e)!e.hasOwnProperty(t)||e[t]instanceof Function||i.has(t)||n.add(t);const m=Array.from(n.values());let d=!0;for(const n in m){const a=m[n];if(!i.has(a)&&(d=o(t[a],e[a]),!d))break}return r.delete(t),r.delete(e),d}return!1};return o(t,e)}process(t){const{textures:e,materials:n}=this;let a=0;const r=t=>{let r=null;for(const e in n){const a=n[e];this.areEqual(t,a)&&(r=a)}if(r)return a++,r;if(n.push(t),this.shareTextures)for(const n in t){if(!t.hasOwnProperty(n))continue;const a=t[n];if(a&&a.isTexture&&a.image instanceof Image){let r=null;for(const t in e){const n=e[t];if(this.areEqual(n,a)){r=n;break}}r?t[n]=r:e.push(a)}}return t};return t.traverse((t=>{if(t.isMesh&&t.material){const e=t.material;if(Array.isArray(e))for(let t=0;t<e.length;t++)e[t]=r(e[t]);else t.material=r(e)}})),{replaced:a,retained:n.length}}}})),r.register("csrdQ",(function(e,n){t(e.exports,"PhysicalCamera",(()=>i));var a=r("ilwiq");class i extends a.PerspectiveCamera{set bokehSize(t){this.fStop=this.getFocalLength()/t}get bokehSize(){return this.getFocalLength()/this.fStop}constructor(...t){super(...t),this.fStop=1.4,this.apertureBlades=0,this.apertureRotation=0,this.focusDistance=25,this.anamorphicRatio=1}}})),r.register("1uEwp",(function(e,n){t(e.exports,"EquirectCamera",(()=>i));var a=r("ilwiq");class i extends a.Camera{constructor(){super(),this.isEquirectCamera=!0}}})),r.register("eLX8K",(function(e,n){t(e.exports,"BlurredEnvMapGenerator",(()=>c));var a=r("ilwiq"),i=r("RPVlj"),o=r("9fZ6X"),s=r("jNhCl");class l extends o.MaterialBase{constructor(){super({uniforms:{envMap:{value:null},blur:{value:0}},vertexShader:"\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}\n\n\t\t\t",fragmentShader:`\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\t\t${s.shaderUtils}\n\n\t\t\t\tuniform sampler2D envMap;\n\t\t\t\tuniform float blur;\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 rayDirection = equirectUvToDirection( vUv );\n\t\t\t\t\tgl_FragColor = textureCubeUV( envMap, rayDirection, blur );\n\n\t\t\t\t}\n\n\t\t\t`})}}class c{constructor(t){this.renderer=t,this.pmremGenerator=new a.PMREMGenerator(t),this.copyQuad=new i.FullScreenQuad(new l),this.renderTarget=new a.WebGLRenderTarget(1,1,{type:a.FloatType,format:a.RGBAFormat})}dispose(){this.pmremGenerator.dispose(),this.copyQuad.dispose(),this.renderTarget.dispose()}generate(t,e){const{pmremGenerator:n,renderTarget:r,copyQuad:i,renderer:o}=this,s=n.fromEquirectangular(t),{width:l,height:c}=t.image;r.setSize(l,c),i.material.envMap=s.texture,i.material.blur=e;const h=o.getRenderTarget(),u=o.autoClear;o.setRenderTarget(r),o.autoClear=!0,i.render(o),o.setRenderTarget(h),o.autoClear=u;const f=new Float32Array(l*c*4);o.readRenderTargetPixels(r,0,0,l,c,f);const m=new a.DataTexture(f,l,c,a.RGBAFormat,a.FloatType);return m.minFilter=t.minFilter,m.magFilter=t.magFilter,m.wrapS=t.wrapS,m.wrapT=t.wrapT,m.mapping=a.EquirectangularReflectionMapping,m.needsUpdate=!0,m}}})),r.register("9dwDm",(function(e,n){t(e.exports,"PhysicalPathTracingMaterial",(()=>v));var a=r("ilwiq"),i=r("9fZ6X"),o=r("8Zfx2"),s=r("5Wq6T"),l=r("laA5G"),c=r("12pjC"),h=r("fcAdp"),u=r("1RTaa"),f=r("22srR"),m=r("jNhCl"),d=r("iyhQ7"),p=r("kAJM1"),g=r("jNveS");class v extends i.MaterialBase{onBeforeRender(){this.setDefine("FEATURE_DOF",0===this.physicalCamera.bokehSize?0:1)}constructor(t){super({transparent:!0,depthWrite:!1,defines:{FEATURE_MIS:1,FEATURE_DOF:1,FEATURE_GRADIENT_BG:0,TRANSPARENT_TRAVERSALS:5,CAMERA_TYPE:0},uniforms:{resolution:{value:new a.Vector2},bounces:{value:3},physicalCamera:{value:new d.PhysicalCameraUniform},bvh:{value:new o.MeshBVHUniformStruct},normalAttribute:{value:new o.FloatVertexAttributeTexture},tangentAttribute:{value:new o.FloatVertexAttributeTexture},uvAttribute:{value:new o.FloatVertexAttributeTexture},materialIndexAttribute:{value:new o.UIntVertexAttributeTexture},materials:{value:new l.MaterialsTexture},textures:{value:(new c.RenderTarget2DArray).texture},lights:{value:new g.LightsTexture},lightCount:{value:0},cameraWorldMatrix:{value:new a.Matrix4},invProjectionMatrix:{value:new a.Matrix4},backgroundBlur:{value:0},environmentIntensity:{value:1},environmentRotation:{value:new a.Matrix3},envMapInfo:{value:new p.EquirectHdrInfoUniform},seed:{value:0},opacity:{value:1},filterGlossyFactor:{value:0},bgGradientTop:{value:new a.Color(1118481)},bgGradientBottom:{value:new a.Color(0)},backgroundAlpha:{value:1}},vertexShader:"\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 mvPosition = vec4( position, 1.0 );\n\t\t\t\t\tmvPosition = modelViewMatrix * mvPosition;\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t\tvUv = uv;\n\n\t\t\t\t}\n\n\t\t\t",fragmentShader:`\n\t\t\t\t#define RAY_OFFSET 1e-4\n\n\t\t\t\tprecision highp isampler2D;\n\t\t\t\tprecision highp usampler2D;\n\t\t\t\tprecision highp sampler2DArray;\n\t\t\t\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\n\t\t\t\t#include <common>\n\n\t\t\t\t${o.shaderStructs}\n\t\t\t\t${o.shaderIntersectFunction}\n\t\t\t\t${s.shaderMaterialStructs}\n\t\t\t\t${s.shaderLightStruct}\n\n\t\t\t\t${m.shaderUtils}\n\t\t\t\t${h.shaderMaterialSampling}\n\t\t\t\t${u.shaderEnvMapSampling}\n\t\t\t\t${f.shaderLightSampling}\n\n\t\t\t\tuniform mat3 environmentRotation;\n\t\t\t\tuniform float backgroundBlur;\n\t\t\t\tuniform float backgroundAlpha;\n\n\t\t\t\t#if FEATURE_GRADIENT_BG\n\n\t\t\t\tuniform vec3 bgGradientTop;\n\t\t\t\tuniform vec3 bgGradientBottom;\n\n\t\t\t\t#endif\n\n\t\t\t\t#if FEATURE_DOF\n\n\t\t\t\tuniform PhysicalCamera physicalCamera;\n\n\t\t\t\t#endif\n\n\t\t\t\tuniform vec2 resolution;\n\t\t\t\tuniform int bounces;\n\t\t\t\tuniform mat4 cameraWorldMatrix;\n\t\t\t\tuniform mat4 invProjectionMatrix;\n\t\t\t\tuniform sampler2D normalAttribute;\n\t\t\t\tuniform sampler2D tangentAttribute;\n\t\t\t\tuniform sampler2D uvAttribute;\n\t\t\t\tuniform usampler2D materialIndexAttribute;\n\t\t\t\tuniform BVH bvh;\n\t\t\t\tuniform float environmentIntensity;\n\t\t\t\tuniform float filterGlossyFactor;\n\t\t\t\tuniform int seed;\n\t\t\t\tuniform float opacity;\n\t\t\t\tuniform sampler2D materials;\n\t\t\t\tuniform sampler2D lights;\n\t\t\t\tuniform uint lightCount;\n\n\t\t\t\tuniform EquirectHdrInfo envMapInfo;\n\n\t\t\t\tuniform sampler2DArray textures;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvec3 sampleBackground( vec3 direction ) {\n\n\t\t\t\t\t#if FEATURE_GRADIENT_BG\n\n\t\t\t\t\tdirection = normalize( direction + randDirection() * 0.05 );\n\n\t\t\t\t\tfloat value = ( direction.y + 1.0 ) / 2.0;\n\t\t\t\t\tvalue = pow( value, 2.0 );\n\n\t\t\t\t\treturn mix( bgGradientBottom, bgGradientTop, value );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\tvec3 sampleDir = normalize( direction + getHemisphereSample( direction, rand2() ) * 0.5 * backgroundBlur );\n\t\t\t\t\treturn environmentIntensity * sampleEquirectEnvMapColor( sampleDir, envMapInfo.map );\n\n\t\t\t\t\t#endif\n\n\t\t\t\t}\n\n\t\t\t\t// step through multiple surface hits and accumulate color attenuation based on transmissive surfaces\n\t\t\t\tbool attenuateHit( BVH bvh, vec3 rayOrigin, vec3 rayDirection, int traversals, bool isShadowRay, out vec3 color ) {\n\n\t\t\t\t\t// hit results\n\t\t\t\t\tuvec4 faceIndices = uvec4( 0u );\n\t\t\t\t\tvec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\n\t\t\t\t\tvec3 barycoord = vec3( 0.0 );\n\t\t\t\t\tfloat side = 1.0;\n\t\t\t\t\tfloat dist = 0.0;\n\n\t\t\t\t\tcolor = vec3( 1.0 );\n\n\t\t\t\t\tfor ( int i = 0; i < traversals; i ++ ) {\n\n\t\t\t\t\t\tif ( bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist ) ) {\n\n\t\t\t\t\t\t\t// TODO: attenuate the contribution based on the PDF of the resulting ray including refraction values\n\t\t\t\t\t\t\t// Should be able to work using the material BSDF functions which will take into account specularity, etc.\n\t\t\t\t\t\t\t// TODO: should we account for emissive surfaces here?\n\n\t\t\t\t\t\t\tvec2 uv = textureSampleBarycoord( uvAttribute, barycoord, faceIndices.xyz ).xy;\n\t\t\t\t\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, faceIndices.x ).r;\n\t\t\t\t\t\t\tMaterial material = readMaterialInfo( materials, materialIndex );\n\n\t\t\t\t\t\t\t// adjust the ray to the new surface\n\t\t\t\t\t\t\tbool isBelowSurface = dot( rayDirection, faceNormal ) < 0.0;\n\t\t\t\t\t\t\tvec3 point = rayOrigin + rayDirection * dist;\n\t\t\t\t\t\t\tvec3 absPoint = abs( point );\n\t\t\t\t\t\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\n\t\t\t\t\t\t\trayOrigin = point + faceNormal * ( maxPoint + 1.0 ) * ( isBelowSurface ? - RAY_OFFSET : RAY_OFFSET );\n\n\t\t\t\t\t\t\tif ( ! material.castShadow && isShadowRay ) {\n\n\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Opacity Test\n\n\t\t\t\t\t\t\t// albedo\n\t\t\t\t\t\t\tvec4 albedo = vec4( material.color, material.opacity );\n\t\t\t\t\t\t\tif ( material.map != - 1 ) {\n\n\t\t\t\t\t\t\t\tvec3 uvPrime = material.mapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\t\talbedo *= texture2D( textures, vec3( uvPrime.xy, material.map ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// alphaMap\n\t\t\t\t\t\t\tif ( material.alphaMap != -1 ) {\n\n\t\t\t\t\t\t\t\talbedo.a *= texture2D( textures, vec3( uv, material.alphaMap ) ).x;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// transmission\n\t\t\t\t\t\t\tfloat transmission = material.transmission;\n\t\t\t\t\t\t\tif ( material.transmissionMap != - 1 ) {\n\n\t\t\t\t\t\t\t\tvec3 uvPrime = material.transmissionMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\t\ttransmission *= texture2D( textures, vec3( uvPrime.xy, material.transmissionMap ) ).r;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// metalness\n\t\t\t\t\t\t\tfloat metalness = material.metalness;\n\t\t\t\t\t\t\tif ( material.metalnessMap != - 1 ) {\n\n\t\t\t\t\t\t\t\tvec3 uvPrime = material.metalnessMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\t\tmetalness *= texture2D( textures, vec3( uvPrime.xy, material.metalnessMap ) ).b;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfloat alphaTest = material.alphaTest;\n\t\t\t\t\t\t\tbool useAlphaTest = alphaTest != 0.0;\n\t\t\t\t\t\t\tfloat transmissionFactor = ( 1.0 - metalness ) * transmission;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\ttransmissionFactor < rand() && ! (\n\t\t\t\t\t\t\t\t\t// material sidedness\n\t\t\t\t\t\t\t\t\tmaterial.side != 0.0 && side == material.side\n\n\t\t\t\t\t\t\t\t\t// alpha test\n\t\t\t\t\t\t\t\t\t|| useAlphaTest && albedo.a < alphaTest\n\n\t\t\t\t\t\t\t\t\t// opacity\n\t\t\t\t\t\t\t\t\t|| ! useAlphaTest && albedo.a < rand()\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// only attenuate on the way in\n\t\t\t\t\t\t\tif ( isBelowSurface ) {\n\n\t\t\t\t\t\t\t\tcolor *= mix( vec3( 1.0 ), albedo.rgb, transmissionFactor );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\t// returns whether the ray hit anything before a certain distance, not just the first surface. Could be optimized to not check the full hierarchy.\n\t\t\t\tbool anyCloserHit( BVH bvh, vec3 rayOrigin, vec3 rayDirection, float maxDist ) {\n\n\t\t\t\t\tuvec4 faceIndices = uvec4( 0u );\n\t\t\t\t\tvec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\n\t\t\t\t\tvec3 barycoord = vec3( 0.0 );\n\t\t\t\t\tfloat side = 1.0;\n\t\t\t\t\tfloat dist = 0.0;\n\t\t\t\t\tbool hit = bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );\n\t\t\t\t\treturn hit && dist < maxDist;\n\n\t\t\t\t}\n\n\t\t\t\t// tentFilter from Peter Shirley's 'Realistic Ray Tracing (2nd Edition)' book, pg. 60\n\t\t\t\t// erichlof/THREE.js-PathTracing-Renderer/\n\t\t\t\tfloat tentFilter( float x ) {\n\n\t\t\t\t\treturn x < 0.5 ? sqrt( 2.0 * x ) - 1.0 : 1.0 - sqrt( 2.0 - ( 2.0 * x ) );\n\n\t\t\t\t}\n\n\t\t\t\tvec3 ndcToRayOrigin( vec2 coord ) {\n\n\t\t\t\t\tvec4 rayOrigin4 = cameraWorldMatrix * invProjectionMatrix * vec4( coord, - 1.0, 1.0 );\n\t\t\t\t\treturn rayOrigin4.xyz / rayOrigin4.w;\n\t\t\t\t}\n\n\t\t\t\tvoid getCameraRay( out vec3 rayDirection, out vec3 rayOrigin ) {\n\n\t\t\t\t\tvec2 ssd = vec2( 1.0 ) / resolution;\n\n\t\t\t\t\t// Jitter the camera ray by finding a uv coordinate at a random sample\n\t\t\t\t\t// around this pixel's UV coordinate\n\t\t\t\t\tvec2 jitteredUv = vUv + vec2( tentFilter( rand() ) * ssd.x, tentFilter( rand() ) * ssd.y );\n\n\t\t\t\t\t#if CAMERA_TYPE == 2\n\n\t\t\t\t\t\t// Equirectangular projection\n\n\t\t\t\t\t\tvec4 rayDirection4 = vec4( equirectUvToDirection( jitteredUv ), 0.0 );\n\t\t\t\t\t\tvec4 rayOrigin4 = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\t\t\trayDirection4 = cameraWorldMatrix * rayDirection4;\n\t\t\t\t\t\trayOrigin4 = cameraWorldMatrix * rayOrigin4;\n\n\t\t\t\t\t\trayDirection = normalize( rayDirection4.xyz );\n\t\t\t\t\t\trayOrigin = rayOrigin4.xyz / rayOrigin4.w;\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\t// get [-1, 1] normalized device coordinates\n\t\t\t\t\t\tvec2 ndc = 2.0 * jitteredUv - vec2( 1.0 );\n\n\t\t\t\t\t\trayOrigin = ndcToRayOrigin( ndc );\n\n\t\t\t\t\t\t#if CAMERA_TYPE == 1\n\n\t\t\t\t\t\t\t// Orthographic projection\n\n\t\t\t\t\t\t\trayDirection = ( cameraWorldMatrix * vec4( 0.0, 0.0, -1.0, 0.0 ) ).xyz;\n\t\t\t\t\t\t\trayDirection = normalize( rayDirection );\n\n\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\t// Perspective projection\n\n\t\t\t\t\t\t\trayDirection = normalize( mat3(cameraWorldMatrix) * ( invProjectionMatrix * vec4( ndc, 0.0, 1.0 ) ).xyz );\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if FEATURE_DOF\n\t\t\t\t\t{\n\n\t\t\t\t\t\t// depth of field\n\t\t\t\t\t\tvec3 focalPoint = rayOrigin + normalize( rayDirection ) * physicalCamera.focusDistance;\n\n\t\t\t\t\t\t// get the aperture sample\n\t\t\t\t\t\tvec2 apertureSample = sampleAperture( physicalCamera.apertureBlades ) * physicalCamera.bokehSize * 0.5 * 1e-3;\n\n\t\t\t\t\t\t// rotate the aperture shape\n\t\t\t\t\t\tfloat ac = cos( physicalCamera.apertureRotation );\n\t\t\t\t\t\tfloat as = sin( physicalCamera.apertureRotation );\n\t\t\t\t\t\tapertureSample = vec2(\n\t\t\t\t\t\t\tapertureSample.x * ac - apertureSample.y * as,\n\t\t\t\t\t\t\tapertureSample.x * as + apertureSample.y * ac\n\t\t\t\t\t\t);\n\t\t\t\t\t\tapertureSample.x *= saturate( physicalCamera.anamorphicRatio );\n\t\t\t\t\t\tapertureSample.y *= saturate( 1.0 / physicalCamera.anamorphicRatio );\n\n\t\t\t\t\t\t// create the new ray\n\t\t\t\t\t\trayOrigin += ( cameraWorldMatrix * vec4( apertureSample, 0.0, 0.0 ) ).xyz;\n\t\t\t\t\t\trayDirection = focalPoint - rayOrigin;\n\n\t\t\t\t\t}\n\t\t\t\t\t#endif\n\n\t\t\t\t\trayDirection = normalize( rayDirection );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\trng_initialize( gl_FragCoord.xy, seed );\n\n\t\t\t\t\tvec3 rayDirection;\n\t\t\t\t\tvec3 rayOrigin;\n\n\t\t\t\t\tgetCameraRay( rayDirection, rayOrigin );\n\n\t\t\t\t\t// inverse environment rotation\n\t\t\t\t\tmat3 invEnvironmentRotation = inverse( environmentRotation );\n\n\t\t\t\t\t// final color\n\t\t\t\t\tgl_FragColor = vec4( 0.0 );\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t\t// hit results\n\t\t\t\t\tuvec4 faceIndices = uvec4( 0u );\n\t\t\t\t\tvec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\n\t\t\t\t\tvec3 barycoord = vec3( 0.0 );\n\t\t\t\t\tfloat side = 1.0;\n\t\t\t\t\tfloat dist = 0.0;\n\n\t\t\t\t\t// path tracing state\n\t\t\t\t\tfloat accumulatedRoughness = 0.0;\n\t\t\t\t\tfloat accumulatedClearcoatRoughness = 0.0;\n\t\t\t\t\tbool transmissiveRay = true;\n\t\t\t\t\tint transparentTraversals = TRANSPARENT_TRAVERSALS;\n\t\t\t\t\tvec3 throughputColor = vec3( 1.0 );\n\t\t\t\t\tSampleRec sampleRec;\n\t\t\t\t\tint i;\n\t\t\t\t\tbool isShadowRay = false;\n\n\t\t\t\t\tfor ( i = 0; i < bounces; i ++ ) {\n\n\t\t\t\t\t\tbool hit = bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );\n\n\t\t\t\t\t\tLightSampleRec lightHit = lightsClosestHit( lights, lightCount, rayOrigin, rayDirection );\n\n\t\t\t\t\t\tif ( lightHit.hit && ( lightHit.dist < dist || !hit ) ) {\n\n\t\t\t\t\t\t\tif ( i == 0 || transmissiveRay ) {\n\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightHit.emission * throughputColor;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t#if FEATURE_MIS\n\n\t\t\t\t\t\t\t\t// weight the contribution\n\t\t\t\t\t\t\t\tfloat misWeight = misHeuristic( sampleRec.pdf, lightHit.pdf / float( lightCount + 1u ) );\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightHit.emission * throughputColor * misWeight;\n\n\t\t\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\t\tgl_FragColor.rgb +=\n\t\t\t\t\t\t\t\t\tlightHit.emission *\n\t\t\t\t\t\t\t\t\tthroughputColor;\n\n\t\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( ! hit ) {\n\n\t\t\t\t\t\t\tif ( i == 0 || transmissiveRay ) {\n\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += sampleBackground( environmentRotation * rayDirection ) * throughputColor;\n\t\t\t\t\t\t\t\tgl_FragColor.a = backgroundAlpha;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t#if FEATURE_MIS\n\n\t\t\t\t\t\t\t\t// get the PDF of the hit envmap point\n\t\t\t\t\t\t\t\tvec3 envColor;\n\t\t\t\t\t\t\t\tfloat envPdf = envMapSample( environmentRotation * rayDirection, envMapInfo, envColor );\n\t\t\t\t\t\t\t\tenvPdf /= float( lightCount + 1u );\n\n\t\t\t\t\t\t\t\t// and weight the contribution\n\t\t\t\t\t\t\t\tfloat misWeight = misHeuristic( sampleRec.pdf, envPdf );\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += environmentIntensity * envColor * throughputColor * misWeight;\n\n\t\t\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\t\tgl_FragColor.rgb +=\n\t\t\t\t\t\t\t\t\tenvironmentIntensity *\n\t\t\t\t\t\t\t\t\tsampleEquirectEnvMapColor( environmentRotation * rayDirection, envMapInfo.map ) *\n\t\t\t\t\t\t\t\t\tthroughputColor;\n\n\t\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, faceIndices.x ).r;\n\t\t\t\t\t\tMaterial material = readMaterialInfo( materials, materialIndex );\n\n\t\t\t\t\t\tif ( material.matte && i == 0 ) {\n\n\t\t\t\t\t\t\tgl_FragColor = vec4( 0.0 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if we've determined that this is a shadow ray and we've hit an item with no shadow casting\n\t\t\t\t\t\t// then skip it\n\t\t\t\t\t\tif ( ! material.castShadow && isShadowRay ) {\n\n\t\t\t\t\t\t\tvec3 point = rayOrigin + rayDirection * dist;\n\t\t\t\t\t\t\tvec3 absPoint = abs( point );\n\t\t\t\t\t\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\n\t\t\t\t\t\t\trayOrigin = point - ( maxPoint + 1.0 ) * faceNormal * RAY_OFFSET;\n\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvec2 uv = textureSampleBarycoord( uvAttribute, barycoord, faceIndices.xyz ).xy;\n\t\t\t\t\t\t// albedo\n\t\t\t\t\t\tvec4 albedo = vec4( material.color, material.opacity );\n\t\t\t\t\t\tif ( material.map != - 1 ) {\n\n\t\t\t\t\t\t\tvec3 uvPrime = material.mapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\talbedo *= texture2D( textures, vec3( uvPrime.xy, material.map ) );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// alphaMap\n\t\t\t\t\t\tif ( material.alphaMap != -1 ) {\n\n\t\t\t\t\t\t\talbedo.a *= texture2D( textures, vec3( uv, material.alphaMap ) ).x;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// possibly skip this sample if it's transparent, alpha test is enabled, or we hit the wrong material side\n\t\t\t\t\t\t// and it's single sided.\n\t\t\t\t\t\t// - alpha test is disabled when it === 0\n\t\t\t\t\t\t// - the material sidedness test is complicated because we want light to pass through the back side but still\n\t\t\t\t\t\t// be able to see the front side. This boolean checks if the side we hit is the front side on the first ray\n\t\t\t\t\t\t// and we're rendering the other then we skip it. Do the opposite on subsequent bounces to get incoming light.\n\t\t\t\t\t\tfloat alphaTest = material.alphaTest;\n\t\t\t\t\t\tbool useAlphaTest = alphaTest != 0.0;\n\t\t\t\t\t\tbool isFirstHit = i == 0;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t// material sidedness\n\t\t\t\t\t\t\tmaterial.side != 0.0 && ( side != material.side ) == isFirstHit\n\n\t\t\t\t\t\t\t// alpha test\n\t\t\t\t\t\t\t|| useAlphaTest && albedo.a < alphaTest\n\n\t\t\t\t\t\t\t// opacity\n\t\t\t\t\t\t\t|| ! useAlphaTest && albedo.a < rand()\n\t\t\t\t\t\t) {\n\n\t\t\t\t\t\t\tvec3 point = rayOrigin + rayDirection * dist;\n\t\t\t\t\t\t\tvec3 absPoint = abs( point );\n\t\t\t\t\t\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\n\t\t\t\t\t\t\trayOrigin = point - ( maxPoint + 1.0 ) * faceNormal * RAY_OFFSET;\n\n\t\t\t\t\t\t\t// only allow a limited number of transparency discards otherwise we could\n\t\t\t\t\t\t\t// crash the context with too long a loop.\n\t\t\t\t\t\t\ti -= sign( transparentTraversals );\n\t\t\t\t\t\t\ttransparentTraversals -= sign( transparentTraversals );\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// fetch the interpolated smooth normal\n\t\t\t\t\t\tvec3 normal = normalize( textureSampleBarycoord(\n\t\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\t\tbarycoord,\n\t\t\t\t\t\t\tfaceIndices.xyz\n\t\t\t\t\t\t).xyz );\n\n\t\t\t\t\t\t// roughness\n\t\t\t\t\t\tfloat roughness = material.roughness;\n\t\t\t\t\t\tif ( material.roughnessMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec3 uvPrime = material.roughnessMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\troughness *= texture2D( textures, vec3( uvPrime.xy, material.roughnessMap ) ).g;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// metalness\n\t\t\t\t\t\tfloat metalness = material.metalness;\n\t\t\t\t\t\tif ( material.metalnessMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec3 uvPrime = material.metalnessMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\tmetalness *= texture2D( textures, vec3( uvPrime.xy, material.metalnessMap ) ).b;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// emission\n\t\t\t\t\t\tvec3 emission = material.emissiveIntensity * material.emissive;\n\t\t\t\t\t\tif ( material.emissiveMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec3 uvPrime = material.emissiveMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\temission *= texture2D( textures, vec3( uvPrime.xy, material.emissiveMap ) ).xyz;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// transmission\n\t\t\t\t\t\tfloat transmission = material.transmission;\n\t\t\t\t\t\tif ( material.transmissionMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec3 uvPrime = material.transmissionMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\ttransmission *= texture2D( textures, vec3( uvPrime.xy, material.transmissionMap ) ).r;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// normal\n\t\t\t\t\t\tvec3 baseNormal = normal;\n\t\t\t\t\t\tif ( material.normalMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec4 tangentSample = textureSampleBarycoord(\n\t\t\t\t\t\t\t\ttangentAttribute,\n\t\t\t\t\t\t\t\tbarycoord,\n\t\t\t\t\t\t\t\tfaceIndices.xyz\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// some provided tangents can be malformed (0, 0, 0) causing the normal to be degenerate\n\t\t\t\t\t\t\t// resulting in NaNs and slow path tracing.\n\t\t\t\t\t\t\tif ( length( tangentSample.xyz ) > 0.0 ) {\n\n\t\t\t\t\t\t\t\tvec3 tangent = normalize( tangentSample.xyz );\n\t\t\t\t\t\t\t\tvec3 bitangent = normalize( cross( normal, tangent ) * tangentSample.w );\n\t\t\t\t\t\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\n\t\t\t\t\t\t\t\tvec3 uvPrime = material.normalMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\t\tvec3 texNormal = texture2D( textures, vec3( uvPrime.xy, material.normalMap ) ).xyz * 2.0 - 1.0;\n\t\t\t\t\t\t\t\ttexNormal.xy *= material.normalScale;\n\t\t\t\t\t\t\t\tnormal = vTBN * texNormal;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnormal *= side;\n\n\t\t\t\t\t\t// clearcoat\n\t\t\t\t\t\tfloat clearcoat = material.clearcoat;\n\t\t\t\t\t\tif ( material.clearcoatMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec3 uvPrime = material.clearcoatMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\tclearcoat *= texture2D( textures, vec3( uvPrime.xy, material.clearcoatMap ) ).r;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// clearcoatRoughness\n\t\t\t\t\t\tfloat clearcoatRoughness = material.clearcoatRoughness;\n\t\t\t\t\t\tif ( material.clearcoatRoughnessMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec3 uvPrime = material.clearcoatRoughnessMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\tclearcoat *= texture2D( textures, vec3( uvPrime.xy, material.clearcoatRoughnessMap ) ).g;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// clearcoatNormal\n\t\t\t\t\t\tvec3 clearcoatNormal = baseNormal;\n\t\t\t\t\t\tif ( material.clearcoatNormalMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec4 tangentSample = textureSampleBarycoord(\n\t\t\t\t\t\t\t\ttangentAttribute,\n\t\t\t\t\t\t\t\tbarycoord,\n\t\t\t\t\t\t\t\tfaceIndices.xyz\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// some provided tangents can be malformed (0, 0, 0) causing the normal to be degenerate\n\t\t\t\t\t\t\t// resulting in NaNs and slow path tracing.\n\t\t\t\t\t\t\tif ( length( tangentSample.xyz ) > 0.0 ) {\n\n\t\t\t\t\t\t\t\tvec3 tangent = normalize( tangentSample.xyz );\n\t\t\t\t\t\t\t\tvec3 bitangent = normalize( cross( clearcoatNormal, tangent ) * tangentSample.w );\n\t\t\t\t\t\t\t\tmat3 vTBN = mat3( tangent, bitangent, clearcoatNormal );\n\n\t\t\t\t\t\t\t\tvec3 uvPrime = material.clearcoatNormalMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\t\tvec3 texNormal = texture2D( textures, vec3( uvPrime.xy, material.clearcoatNormalMap ) ).xyz * 2.0 - 1.0;\n\t\t\t\t\t\t\t\ttexNormal.xy *= material.clearcoatNormalScale;\n\t\t\t\t\t\t\t\tclearcoatNormal = vTBN * texNormal;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tclearcoatNormal *= side;\n\n\t\t\t\t\t\t// sheenColor\n\t\t\t\t\t\tvec3 sheenColor = material.sheenColor;\n\t\t\t\t\t\tif ( material.sheenColorMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec3 uvPrime = material.sheenColorMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\tsheenColor *= texture2D( textures, vec3( uvPrime.xy, material.sheenColorMap ) ).rgb;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// sheenRoughness\n\t\t\t\t\t\tfloat sheenRoughness = material.sheenRoughness;\n\t\t\t\t\t\tif ( material.sheenRoughnessMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec3 uvPrime = material.sheenRoughnessMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\tsheenRoughness *= texture2D( textures, vec3( uvPrime.xy, material.sheenRoughnessMap ) ).a;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// iridescence\n\t\t\t\t\t\tfloat iridescence = material.iridescence;\n\t\t\t\t\t\tif ( material.iridescenceMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec3 uvPrime = material.iridescenceMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\tiridescence *= texture2D( textures, vec3( uvPrime.xy, material.iridescenceMap ) ).r;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// iridescence thickness\n\t\t\t\t\t\tfloat iridescenceThickness = material.iridescenceThicknessMaximum;\n\t\t\t\t\t\tif ( material.iridescenceThicknessMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec3 uvPrime = material.iridescenceThicknessMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\tfloat iridescenceThicknessSampled = texture2D( textures, vec3( uvPrime.xy, material.iridescenceThicknessMap ) ).g;\n\t\t\t\t\t\t\tiridescenceThickness = mix( material.iridescenceThicknessMinimum, material.iridescenceThicknessMaximum, iridescenceThicknessSampled );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tiridescence = iridescenceThickness == 0.0 ? 0.0 : iridescence;\n\n\t\t\t\t\t\tSurfaceRec surfaceRec;\n\t\t\t\t\t\tsurfaceRec.normal = normal;\n\t\t\t\t\t\tsurfaceRec.faceNormal = faceNormal;\n\t\t\t\t\t\tsurfaceRec.transmission = transmission;\n\t\t\t\t\t\tsurfaceRec.ior = material.ior;\n\t\t\t\t\t\tsurfaceRec.emission = emission;\n\t\t\t\t\t\tsurfaceRec.metalness = metalness;\n\t\t\t\t\t\tsurfaceRec.color = albedo.rgb;\n\t\t\t\t\t\tsurfaceRec.roughness = roughness;\n\t\t\t\t\t\tsurfaceRec.clearcoat = clearcoat;\n\t\t\t\t\t\tsurfaceRec.clearcoatRoughness = clearcoatRoughness;\n\t\t\t\t\t\tsurfaceRec.sheenColor = sheenColor;\n\t\t\t\t\t\tsurfaceRec.sheenRoughness = sheenRoughness;\n\t\t\t\t\t\tsurfaceRec.iridescence = iridescence;\n\t\t\t\t\t\tsurfaceRec.iridescenceIor = material.iridescenceIor;\n\t\t\t\t\t\tsurfaceRec.iridescenceThickness = iridescenceThickness;\n\n\t\t\t\t\t\t// frontFace is used to determine transmissive properties and PDF. If no transmission is used\n\t\t\t\t\t\t// then we can just always assume this is a front face.\n\t\t\t\t\t\tsurfaceRec.frontFace = side == 1.0 || transmission == 0.0;\n\n\t\t\t\t\t\t// Compute the filtered roughness value to use during specular reflection computations.\n\t\t\t\t\t\t// The accumulated roughness value is scaled by a user setting and a "magic value" of 5.0.\n\t\t\t\t\t\t// If we're exiting something transmissive then scale the factor down significantly so we can retain\n\t\t\t\t\t\t// sharp internal reflections\n\t\t\t\t\t\tsurfaceRec.filteredRoughness = clamp( max( surfaceRec.roughness, accumulatedRoughness * filterGlossyFactor * 5.0 ), 0.0, 1.0 );\n\t\t\t\t\t\tsurfaceRec.filteredClearcoatRoughness = clamp( max( surfaceRec.clearcoatRoughness, accumulatedClearcoatRoughness * filterGlossyFactor * 5.0 ), 0.0, 1.0 );\n\n\t\t\t\t\t\tmat3 normalBasis = getBasisFromNormal( surfaceRec.normal );\n\t\t\t\t\t\tmat3 invBasis = inverse( normalBasis );\n\n\t\t\t\t\t\tmat3 clearcoatNormalBasis = getBasisFromNormal( clearcoatNormal );\n\t\t\t\t\t\tmat3 clearcoatInvBasis = inverse( clearcoatNormalBasis );\n\n\t\t\t\t\t\tvec3 outgoing = - normalize( invBasis * rayDirection );\n\t\t\t\t\t\tvec3 clearcoatOutgoing = - normalize( clearcoatInvBasis * rayDirection );\n\t\t\t\t\t\tsampleRec = bsdfSample( outgoing, clearcoatOutgoing, normalBasis, invBasis, clearcoatNormalBasis, clearcoatInvBasis, surfaceRec );\n\n\t\t\t\t\t\tisShadowRay = sampleRec.specularPdf < rand();\n\n\t\t\t\t\t\t// adjust the hit point by the surface normal by a factor of some offset and the\n\t\t\t\t\t\t// maximum component-wise value of the current point to accommodate floating point\n\t\t\t\t\t\t// error as values increase.\n\t\t\t\t\t\tvec3 point = rayOrigin + rayDirection * dist;\n\t\t\t\t\t\tvec3 absPoint = abs( point );\n\t\t\t\t\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\n\t\t\t\t\t\trayDirection = normalize( normalBasis * sampleRec.direction );\n\n\t\t\t\t\t\tbool isBelowSurface = dot( rayDirection, faceNormal ) < 0.0;\n\t\t\t\t\t\trayOrigin = point + faceNormal * ( maxPoint + 1.0 ) * ( isBelowSurface ? - RAY_OFFSET : RAY_OFFSET );\n\n\t\t\t\t\t\t// direct env map sampling\n\t\t\t\t\t\t#if FEATURE_MIS\n\n\t\t\t\t\t\t// uniformly pick a light or environment map\n\t\t\t\t\t\tif( rand() > 1.0 / float( lightCount + 1u ) ) {\n\n\t\t\t\t\t\t\t// sample a light or environment\n\t\t\t\t\t\t\tLightSampleRec lightSampleRec = randomLightSample( lights, lightCount, rayOrigin );\n\n\t\t\t\t\t\t\tbool isSampleBelowSurface = dot( faceNormal, lightSampleRec.direction ) < 0.0;\n\t\t\t\t\t\t\tif ( isSampleBelowSurface ) {\n\n\t\t\t\t\t\t\t\tlightSampleRec.pdf = 0.0;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// check if a ray could even reach the light area\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tlightSampleRec.pdf > 0.0 &&\n\t\t\t\t\t\t\t\tisDirectionValid( lightSampleRec.direction, normal, faceNormal ) &&\n\t\t\t\t\t\t\t\t! anyCloserHit( bvh, rayOrigin, lightSampleRec.direction, lightSampleRec.dist )\n\t\t\t\t\t\t\t) {\n\n\t\t\t\t\t\t\t\t// get the material pdf\n\t\t\t\t\t\t\t\tvec3 sampleColor;\n\t\t\t\t\t\t\t\tfloat lightMaterialPdf = bsdfResult( outgoing, clearcoatOutgoing, normalize( invBasis * lightSampleRec.direction ), normalize( clearcoatInvBasis * lightSampleRec.direction ), surfaceRec, sampleColor );\n\t\t\t\t\t\t\t\tbool isValidSampleColor = all( greaterThanEqual( sampleColor, vec3( 0.0 ) ) );\n\t\t\t\t\t\t\t\tif ( lightMaterialPdf > 0.0 && isValidSampleColor ) {\n\n\t\t\t\t\t\t\t\t\t// weight the direct light contribution\n\t\t\t\t\t\t\t\t\tfloat lightPdf = lightSampleRec.pdf / float( lightCount + 1u );\n\t\t\t\t\t\t\t\t\tfloat misWeight = misHeuristic( lightPdf, lightMaterialPdf );\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightSampleRec.emission * throughputColor * sampleColor * misWeight / lightPdf;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// find a sample in the environment map to include in the contribution\n\t\t\t\t\t\t\tvec3 envColor, envDirection;\n\t\t\t\t\t\t\tfloat envPdf = randomEnvMapSample( envMapInfo, envColor, envDirection );\n\t\t\t\t\t\t\tenvDirection = invEnvironmentRotation * envDirection;\n\n\t\t\t\t\t\t\t// this env sampling is not set up for transmissive sampling and yields overly bright\n\t\t\t\t\t\t\t// results so we ignore the sample in this case.\n\t\t\t\t\t\t\t// TODO: this should be improved but how? The env samples could traverse a few layers?\n\t\t\t\t\t\t\tbool isSampleBelowSurface = dot( faceNormal, envDirection ) < 0.0;\n\t\t\t\t\t\t\tif ( isSampleBelowSurface ) {\n\n\t\t\t\t\t\t\t\tenvPdf = 0.0;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// check if a ray could even reach the surface\n\t\t\t\t\t\t\tvec3 attenuatedColor;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tenvPdf > 0.0 &&\n\t\t\t\t\t\t\t\tisDirectionValid( envDirection, normal, faceNormal ) &&\n\t\t\t\t\t\t\t\t! attenuateHit( bvh, rayOrigin, envDirection, bounces - i, isShadowRay, attenuatedColor )\n\t\t\t\t\t\t\t) {\n\n\t\t\t\t\t\t\t\t// get the material pdf\n\t\t\t\t\t\t\t\tvec3 sampleColor;\n\t\t\t\t\t\t\t\tfloat envMaterialPdf = bsdfResult( outgoing, clearcoatOutgoing, normalize( invBasis * envDirection ), normalize( clearcoatInvBasis * envDirection ), surfaceRec, sampleColor );\n\t\t\t\t\t\t\t\tbool isValidSampleColor = all( greaterThanEqual( sampleColor, vec3( 0.0 ) ) );\n\t\t\t\t\t\t\t\tif ( envMaterialPdf > 0.0 && isValidSampleColor ) {\n\n\t\t\t\t\t\t\t\t\t// weight the direct light contribution\n\t\t\t\t\t\t\t\t\tenvPdf /= float( lightCount + 1u );\n\t\t\t\t\t\t\t\t\tfloat misWeight = misHeuristic( envPdf, envMaterialPdf );\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb += attenuatedColor * environmentIntensity * envColor * throughputColor * sampleColor * misWeight / envPdf;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// accumulate a roughness value to offset diffuse, specular, diffuse rays that have high contribution\n\t\t\t\t\t\t// to a single pixel resulting in fireflies\n\t\t\t\t\t\tif ( ! isBelowSurface ) {\n\n\t\t\t\t\t\t\t// determine if this is a rough normal or not by checking how far off straight up it is\n\t\t\t\t\t\t\tvec3 halfVector = normalize( outgoing + sampleRec.direction );\n\t\t\t\t\t\t\taccumulatedRoughness += sin( acosApprox( halfVector.z ) );\n\n\t\t\t\t\t\t\tvec3 clearcoatHalfVector = normalize( clearcoatOutgoing + sampleRec.clearcoatDirection );\n\t\t\t\t\t\t\taccumulatedClearcoatRoughness += sin( acosApprox( clearcoatHalfVector.z ) );\n\n\t\t\t\t\t\t\ttransmissiveRay = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// accumulate color\n\t\t\t\t\t\tgl_FragColor.rgb += ( emission * throughputColor );\n\n\t\t\t\t\t\t// skip the sample if our PDF or ray is impossible\n\t\t\t\t\t\tif ( sampleRec.pdf <= 0.0 || ! isDirectionValid( rayDirection, normal, faceNormal) ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthroughputColor *= sampleRec.color / sampleRec.pdf;\n\n\t\t\t\t\t\t// discard the sample if there are any NaNs\n\t\t\t\t\t\tif ( any( isnan( throughputColor ) ) || any( isinf( throughputColor ) ) ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgl_FragColor.a *= opacity;\n\n\t\t\t\t}\n\n\t\t\t`}),this.setValues(t)}}})),r.register("laA5G",(function(e,n){t(e.exports,"MaterialsTexture",(()=>o));var a=r("ilwiq");const i=152;class o extends a.DataTexture{constructor(){super(new Float32Array(4),1,1),this.format=a.RGBAFormat,this.type=a.FloatType,this.wrapS=a.ClampToEdgeWrapping,this.wrapT=a.ClampToEdgeWrapping,this.generateMipmaps=!1,this.threeCompatibilityTransforms=!1}setCastShadow(t,e){this.image.data[t*i+45]=e?0:1}getCastShadow(t){const e=this.image.data;return!Boolean(e[t*i+45])}setSide(t,e){const n=this.image.data,r=t*i+43;switch(e){case a.FrontSide:n[r]=1;break;case a.BackSide:n[r]=-1;break;case a.DoubleSide:n[r]=0}}getSide(t){switch(this.image.data[t*i+43]){case 0:return a.DoubleSide;case 1:return a.FrontSide;case-1:return a.BackSide}return 0}setMatte(t,e){this.image.data[t*i+44]=e?1:0}getMatte(t){const e=this.image.data;return Boolean(e[t*i+44])}updateFrom(t,e){function n(t,n,a=-1){return n in t?e.indexOf(t[n]):a}function a(t,e,n){return e in t?t[e]:n}function r(t,e,n,a){let r;if(r=l?function(t){return t.map||t.specularMap||t.displacementMap||t.normalMap||t.bumpMap||t.roughnessMap||t.metalnessMap||t.alphaMap||t.emissiveMap||t.clearcoatMap||t.clearcoatNormalMap||t.clearcoatRoughnessMap||t.iridescenceMap||t.iridescenceThicknessMap||t.specularIntensityMap||t.specularColorMap||t.transmissionMap||t.thicknessMap||t.sheenColorMap||t.sheenRoughnessMap||null}(t):t[e]&&t[e].isTexture?t[e]:null,r){const t=r.matrix.elements;let e=0;n[a+e++]=t[0],n[a+e++]=t[3],n[a+e++]=t[6],e++,n[a+e++]=t[1],n[a+e++]=t[4],n[a+e++]=t[7],e++}return 8}let i=0;const o=38*t.length,s=Math.ceil(Math.sqrt(o)),{threeCompatibilityTransforms:l,image:c}=this;c.width!==s&&(this.dispose(),c.data=new Float32Array(s*s*4),c.width=s,c.height=s);const h=c.data;for(let o=0,s=t.length;o<s;o++){const s=t[o];h[i++]=s.color.r,h[i++]=s.color.g,h[i++]=s.color.b,h[i++]=n(s,"map"),h[i++]=a(s,"metalness",0),h[i++]=e.indexOf(s.metalnessMap),h[i++]=a(s,"roughness",0),h[i++]=e.indexOf(s.roughnessMap),h[i++]=a(s,"ior",1),h[i++]=a(s,"transmission",0),h[i++]=n(s,"transmissionMap"),h[i++]=a(s,"emissiveIntensity",0),"emissive"in s?(h[i++]=s.emissive.r,h[i++]=s.emissive.g,h[i++]=s.emissive.b):(h[i++]=0,h[i++]=0,h[i++]=0),h[i++]=n(s,"emissiveMap"),h[i++]=n(s,"normalMap"),"normalScale"in s?(h[i++]=s.normalScale.x,h[i++]=s.normalScale.y):(h[i++]=1,h[i++]=1),h[i++]=a(s,"clearcoat",0),h[i++]=n(s,"clearcoatMap"),h[i++]=a(s,"clearcoatRoughness",0),h[i++]=n(s,"clearcoatRoughnessMap"),h[i++]=n(s,"clearcoatNormalMap"),"clearcoatNormalScale"in s?(h[i++]=s.clearcoatNormalScale.x,h[i++]=s.clearcoatNormalScale.y):(h[i++]=1,h[i++]=1),i++,i++,"sheenColor"in s?(h[i++]=s.sheenColor.r,h[i++]=s.sheenColor.g,h[i++]=s.sheenColor.b):(h[i++]=0,h[i++]=0,h[i++]=0),h[i++]=n(s,"sheenColorMap"),h[i++]=a(s,"sheenRoughness",0),h[i++]=n(s,"sheenRoughnessMap"),h[i++]=n(s,"iridescenceMap"),h[i++]=n(s,"iridescenceThicknessMap"),h[i++]=a(s,"iridescence",0),h[i++]=a(s,"iridescenceIOR",1.3);const l=a(s,"iridescenceThicknessRange",[100,400]);h[i++]=l[0],h[i++]=l[1],h[i++]=n(s,"alphaMap"),h[i++]=s.opacity,h[i++]=s.alphaTest,i++,i++,i++,i++,i++,i+=r(s,"map",h,i),i+=r(s,"metalnessMap",h,i),i+=r(s,"roughnessMap",h,i),i+=r(s,"transmissionMap",h,i),i+=r(s,"emissiveMap",h,i),i+=r(s,"normalMap",h,i),i+=r(s,"clearcoatMap",h,i),i+=r(s,"clearcoatNormalMap",h,i),i+=r(s,"clearcoatRoughnessMap",h,i),i+=r(s,"sheenColorMap",h,i),i+=r(s,"sheenRoughnessMap",h,i),i+=r(s,"iridescenceMap",h,i),i+=r(s,"iridescenceThicknessMap",h,i)}this.needsUpdate=!0}}})),r.register("12pjC",(function(e,n){t(e.exports,"RenderTarget2DArray",(()=>s));var a=r("ilwiq"),i=r("RPVlj");const o=new a.Color;class s extends a.WebGLArrayRenderTarget{constructor(...t){super(...t);const e=this.texture;e.format=a.RGBAFormat,e.type=a.UnsignedByteType,e.minFilter=a.LinearFilter,e.magFilter=a.LinearFilter,e.wrapS=a.RepeatWrapping,e.wrapT=a.RepeatWrapping,e.setTextures=(...t)=>{this.setTextures(...t)};const n=new i.FullScreenQuad(new a.MeshBasicMaterial);this.fsQuad=n}setTextures(t,e,n,r){const i=t.getRenderTarget(),s=t.toneMapping,l=t.getClearAlpha();t.getClearColor(o);const c=r.length||1;this.setSize(e,n,c),t.setClearColor(0,0),t.toneMapping=a.NoToneMapping;const h=this.fsQuad;for(let e=0,n=c;e<n;e++){const n=r[e];n&&(n.matrixAutoUpdate=!1,n.matrix.identity(),h.material.map=n,h.material.transparent=!0,t.setRenderTarget(this,e),h.render(t),n.updateMatrix(),n.matrixAutoUpdate=!0)}h.material.map=null,t.setClearColor(o,l),t.setRenderTarget(i),t.toneMapping=s}dispose(){super.dispose(),this.fsQuad.dispose()}}})),r.register("fcAdp",(function(e,n){t(e.exports,"shaderMaterialSampling",(()=>s));var a=r("bmrjs"),i=r("bQHTv"),o=r("6wwLz");const s=`\n\nstruct SurfaceRec {\n\tvec3 normal;\n\tvec3 faceNormal;\n\tbool frontFace;\n\tfloat roughness;\n\tfloat filteredRoughness;\n\tfloat metalness;\n\tvec3 color;\n\tvec3 emission;\n\tfloat transmission;\n\tfloat ior;\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n\tfloat filteredClearcoatRoughness;\n\tvec3 sheenColor;\n\tfloat sheenRoughness;\n\tfloat iridescence;\n\tfloat iridescenceIor;\n\tfloat iridescenceThickness;\n};\n\nstruct SampleRec {\n\tfloat specularPdf;\n\tfloat pdf;\n\tvec3 direction;\n\tvec3 clearcoatDirection;\n\tvec3 color;\n};\n\n${a.shaderGGXFunctions}\n${i.shaderSheenFunctions}\n${o.shaderIridescenceFunctions}\n\n// diffuse\nfloat diffusePDF( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\t// https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html#lightscattering/thescatteringpdf\n\tfloat cosValue = wi.z;\n\treturn cosValue / PI;\n\n}\n\nvec3 diffuseDirection( vec3 wo, SurfaceRec surf ) {\n\n\tvec3 lightDirection = randDirection();\n\tlightDirection.z += 1.0;\n\tlightDirection = normalize( lightDirection );\n\n\treturn lightDirection;\n\n}\n\nvec3 diffuseColor( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\t// TODO: scale by 1 - F here\n\t// note on division by PI\n\t// https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/\n\tfloat metalFactor = ( 1.0 - surf.metalness ) * wi.z / ( PI * PI );\n\tfloat transmissionFactor = 1.0 - surf.transmission;\n\treturn surf.color * metalFactor * transmissionFactor;\n\n}\n\n// specular\nfloat specularPDF( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\t// See equation (27) in http://jcgt.org/published/0003/02/03/\n\tfloat filteredRoughness = surf.filteredRoughness;\n\tvec3 halfVector = getHalfVector( wi, wo );\n\treturn ggxPDF( wo, halfVector, filteredRoughness ) / ( 4.0 * dot( wi, halfVector ) );\n\n}\n\nvec3 specularDirection( vec3 wo, SurfaceRec surf ) {\n\n\t// sample ggx vndf distribution which gives a new normal\n\tfloat filteredRoughness = surf.filteredRoughness;\n\tvec3 halfVector = ggxDirection(\n\t\two,\n\t\tfilteredRoughness,\n\t\tfilteredRoughness,\n\t\trand(),\n\t\trand()\n\t);\n\n\t// apply to new ray by reflecting off the new normal\n\treturn - reflect( wo, halfVector );\n\n}\n\nvec3 specularColor( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\t// if roughness is set to 0 then D === NaN which results in black pixels\n\tfloat metalness = surf.metalness;\n\tfloat ior = surf.ior;\n\tbool frontFace = surf.frontFace;\n\tfloat filteredRoughness = surf.filteredRoughness;\n\n\tvec3 halfVector = getHalfVector( wo, wi );\n\tfloat iorRatio = frontFace ? 1.0 / ior : ior;\n\tfloat G = ggxShadowMaskG2( wi, wo, filteredRoughness );\n\tfloat D = ggxDistribution( halfVector, filteredRoughness );\n\tvec3 F = vec3( schlickFresnelFromIor( dot( wi, halfVector ), iorRatio ) );\n\n\tfloat cosTheta = min( wo.z, 1.0 );\n\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\tbool cannotRefract = iorRatio * sinTheta > 1.0;\n\tif ( cannotRefract ) {\n\n\t\tF = vec3( 1.0 );\n\n\t}\n\n\tfloat f0 = pow( ( iorRatio - 1.0 ) / ( iorRatio + 1.0 ), 2.0 );\n\tvec3 iridescenceFresnel = evalIridescence( 1.0, surf.iridescenceIor, dot( wi, halfVector ), surf.iridescenceThickness, vec3( f0 ) );\n\tF = mix( F, iridescenceFresnel, surf.iridescence );\n\n\tvec3 color = mix( vec3( 1.0 ), surf.color, metalness );\n\tcolor = mix( color, vec3( 1.0 ), F );\n\tcolor *= G * D / ( 4.0 * abs( wi.z * wo.z ) );\n\tcolor *= mix( F, vec3( 1.0 ), metalness );\n\tcolor *= wi.z; // scale the light by the direction the light is coming in from\n\n\treturn color;\n\n}\n\n/*\n// transmission\nfunction transmissionPDF( wo, wi, material, surf ) {\n\n\t// See section 4.2 in https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n\n\tconst { roughness, ior } = material;\n\tconst { frontFace } = hit;\n\tconst ratio = frontFace ? ior : 1 / ior;\n\tconst minRoughness = Math.max( roughness, MIN_ROUGHNESS );\n\n\thalfVector.set( 0, 0, 0 ).addScaledVector( wi, ratio ).addScaledVector( wo, 1.0 ).normalize().multiplyScalar( - 1 );\n\n\tconst denom = Math.pow( ratio * halfVector.dot( wi ) + 1.0 * halfVector.dot( wo ), 2.0 );\n\treturn ggxPDF( wo, halfVector, minRoughness ) / denom;\n\n}\n\nfunction transmissionDirection( wo, hit, material, lightDirection ) {\n\n\tconst { roughness, ior } = material;\n\tconst { frontFace } = hit;\n\tconst ratio = frontFace ? 1 / ior : ior;\n\tconst minRoughness = Math.max( roughness, MIN_ROUGHNESS );\n\n\t// sample ggx vndf distribution which gives a new normal\n\tggxDirection(\n\t\two,\n\t\tminRoughness,\n\t\tminRoughness,\n\t\tMath.random(),\n\t\tMath.random(),\n\t\thalfVector,\n\t);\n\n\t// apply to new ray by reflecting off the new normal\n\ttempDir.copy( wo ).multiplyScalar( - 1 );\n\trefract( tempDir, halfVector, ratio, lightDirection );\n\n}\n\nfunction transmissionColor( wo, wi, material, hit, colorTarget ) {\n\n\tconst { metalness, transmission } = material;\n\tcolorTarget\n\t\t.copy( material.color )\n\t\t.multiplyScalar( ( 1.0 - metalness ) * wo.z )\n\t\t.multiplyScalar( transmission );\n\n}\n*/\n\n// TODO: This is just using a basic cosine-weighted specular distribution with an\n// incorrect PDF value at the moment. Update it to correctly use a GGX distribution\nfloat transmissionPDF( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\tfloat ior = surf.ior;\n\tbool frontFace = surf.frontFace;\n\n\tfloat ratio = frontFace ? 1.0 / ior : ior;\n\tfloat cosTheta = min( wo.z, 1.0 );\n\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\tfloat reflectance = schlickFresnelFromIor( cosTheta, ratio );\n\tbool cannotRefract = ratio * sinTheta > 1.0;\n\tif ( cannotRefract ) {\n\n\t\treturn 0.0;\n\n\t}\n\n\treturn 1.0 / ( 1.0 - reflectance );\n\n}\n\nvec3 transmissionDirection( vec3 wo, SurfaceRec surf ) {\n\n\tfloat roughness = surf.roughness;\n\tfloat ior = surf.ior;\n\tbool frontFace = surf.frontFace;\n\tfloat ratio = frontFace ? 1.0 / ior : ior;\n\n\tvec3 lightDirection = refract( - wo, vec3( 0.0, 0.0, 1.0 ), ratio );\n\tlightDirection += randDirection() * roughness;\n\treturn normalize( lightDirection );\n\n}\n\nvec3 transmissionColor( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\tfloat metalness = surf.metalness;\n\tfloat transmission = surf.transmission;\n\n\tvec3 color = surf.color;\n\tcolor *= ( 1.0 - metalness );\n\tcolor *= transmission;\n\n\treturn color;\n\n}\n\n// clearcoat\nfloat clearcoatPDF( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\t// See equation (27) in http://jcgt.org/published/0003/02/03/\n\tfloat filteredClearcoatRoughness = surf.filteredClearcoatRoughness;\n\tvec3 halfVector = getHalfVector( wi, wo );\n\treturn ggxPDF( wo, halfVector, filteredClearcoatRoughness ) / ( 4.0 * dot( wi, halfVector ) );\n\n}\n\nvec3 clearcoatDirection( vec3 wo, SurfaceRec surf ) {\n\n\t// sample ggx vndf distribution which gives a new normal\n\tfloat filteredClearcoatRoughness = surf.filteredClearcoatRoughness;\n\tvec3 halfVector = ggxDirection(\n\t\two,\n\t\tfilteredClearcoatRoughness,\n\t\tfilteredClearcoatRoughness,\n\t\trand(),\n\t\trand()\n\t);\n\n\t// apply to new ray by reflecting off the new normal\n\treturn - reflect( wo, halfVector );\n\n}\n\nvoid clearcoatColor( inout vec3 color, vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\tfloat ior = 1.5;\n\tbool frontFace = surf.frontFace;\n\tfloat filteredClearcoatRoughness = surf.filteredClearcoatRoughness;\n\n\tvec3 halfVector = getHalfVector( wo, wi );\n\tfloat iorRatio = frontFace ? 1.0 / ior : ior;\n\tfloat G = ggxShadowMaskG2( wi, wo, filteredClearcoatRoughness );\n\tfloat D = ggxDistribution( halfVector, filteredClearcoatRoughness );\n\n\tfloat F = schlickFresnelFromIor( dot( wi, halfVector ), ior );\n\tfloat cosTheta = min( wo.z, 1.0 );\n\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\tbool cannotRefract = iorRatio * sinTheta > 1.0;\n\tif ( cannotRefract ) {\n\n\t\tF = 1.0;\n\n\t}\n\n\tfloat fClearcoat = F * D * G / ( 4.0 * abs( wi.z * wo.z ) );\n\n\tcolor = color * ( 1.0 - surf.clearcoat * F ) + fClearcoat * surf.clearcoat * wi.z;\n\n}\n\n// sheen\nvec3 sheenColor( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\tvec3 halfVector = getHalfVector( wo, wi );\n\n\tfloat cosThetaO = saturateCos( wo.z );\n\tfloat cosThetaI = saturateCos( wi.z );\n\tfloat cosThetaH = halfVector.z;\n\n\tfloat D = velvetD( cosThetaH, surf.sheenRoughness );\n\tfloat G = velvetG( cosThetaO, cosThetaI, surf.sheenRoughness );\n\n\t// See equation (1) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\n\tvec3 color = surf.sheenColor;\n\tcolor *= D * G / ( 4.0 * abs( cosThetaO * cosThetaI ) );\n\tcolor *= wi.z;\n\n\treturn color;\n\n}\n\n// bsdf\nvoid getLobeWeights( vec3 wo, vec3 clearcoatWo, SurfaceRec surf, out float diffuseWeight, out float specularWeight, out float transmissionWeight, out float clearcoatWeight ) {\n\n\tfloat ior = surf.ior;\n\tfloat metalness = surf.metalness;\n\tfloat transmission = surf.transmission;\n\tbool frontFace = surf.frontFace;\n\n\tfloat ratio = frontFace ? 1.0 / ior : ior;\n\tfloat cosTheta = min( wo.z, 1.0 );\n\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\tfloat reflectance = schlickFresnelFromIor( cosTheta, ratio );\n\tbool cannotRefract = ratio * sinTheta > 1.0;\n\tif ( cannotRefract ) {\n\n\t\treflectance = 1.0;\n\n\t}\n\n\tfloat transSpecularProb = mix( reflectance, 1.0, metalness );\n\tfloat diffSpecularProb = 0.5 + 0.5 * metalness;\n\n\tclearcoatWeight = surf.clearcoat * schlickFresnel( clearcoatWo.z, 0.04 );\n\tdiffuseWeight = ( 1.0 - transmission ) * ( 1.0 - diffSpecularProb ) * ( 1.0 - clearcoatWeight );\n\tspecularWeight = transmission * transSpecularProb + ( 1.0 - transmission ) * diffSpecularProb * ( 1.0 - clearcoatWeight );\n\ttransmissionWeight = transmission * ( 1.0 - transSpecularProb ) * ( 1.0 - clearcoatWeight );\n\n\tfloat totalWeight = diffuseWeight + specularWeight + transmissionWeight + clearcoatWeight;\n\tfloat invTotalWeight = 1.0 / totalWeight;\n\n\tdiffuseWeight *= invTotalWeight;\n\tspecularWeight *= invTotalWeight;\n\ttransmissionWeight *= invTotalWeight;\n\tclearcoatWeight *= invTotalWeight;\n\n}\n\nfloat bsdfPdf( vec3 wo, vec3 clearcoatWo, vec3 wi, vec3 clearcoatWi, SurfaceRec surf, out float specularPdf, float diffuseWeight, float specularWeight, float transmissionWeight, float clearcoatWeight ) {\n\n\tfloat ior = surf.ior;\n\tfloat metalness = surf.metalness;\n\tfloat transmission = surf.transmission;\n\tbool frontFace = surf.frontFace;\n\n\tfloat ratio = frontFace ? 1.0 / ior : ior;\n\tfloat cosTheta = min( wo.z, 1.0 );\n\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\tfloat reflectance = schlickFresnelFromIor( cosTheta, ratio );\n\tbool cannotRefract = ratio * sinTheta > 1.0;\n\tif ( cannotRefract ) {\n\n\t\treflectance = 1.0;\n\n\t}\n\n\tfloat spdf = 0.0;\n\tfloat dpdf = 0.0;\n\tfloat tpdf = 0.0;\n\tfloat cpdf = 0.0;\n\n\tif ( wi.z < 0.0 ) {\n\n\t\tif( transmissionWeight > 0.0 ) {\n\n\t\t\ttpdf = transmissionPDF( wo, wi, surf );\n\n\t\t}\n\n\t} else {\n\n\t\tif( diffuseWeight > 0.0 ) {\n\n\t\t\tdpdf = diffusePDF( wo, wi, surf );\n\n\t\t}\n\n\t\tif( specularWeight > 0.0 ) {\n\n\t\t\tspdf = specularPDF( wo, wi, surf );\n\n\t\t}\n\n\t}\n\n\tif( clearcoatWi.z >= 0.0 && clearcoatWeight > 0.0 ) {\n\n\t\tcpdf = clearcoatPDF( clearcoatWo, clearcoatWi, surf );\n\n\t}\n\n\tfloat pdf =\n\t\t  dpdf * diffuseWeight\n\t\t+ spdf * specularWeight\n\t\t+ tpdf * transmissionWeight\n\t\t+ cpdf * clearcoatWeight;\n\n\t// retrieve specular rays for the shadows flag\n\tspecularPdf = spdf * specularWeight + cpdf * clearcoatWeight;\n\n\treturn pdf;\n\n}\n\nvec3 bsdfColor( vec3 wo, vec3 clearcoatWo, vec3 wi, vec3 clearcoatWi, SurfaceRec surf, float diffuseWeight, float specularWeight, float transmissionWeight, float clearcoatWeight ) {\n\n\tvec3 color = vec3( 0.0 );\n\tif ( wi.z < 0.0 ) {\n\n\t\tif( transmissionWeight > 0.0 ) {\n\n\t\t\tcolor = transmissionColor( wo, wi, surf );\n\n\t\t}\n\n\t} else {\n\n\t\tif( diffuseWeight > 0.0 ) {\n\n\t\t\tcolor = diffuseColor( wo, wi, surf );\n\t\t\tcolor *= 1.0 - surf.transmission;\n\n\t\t}\n\n\t\tif( specularWeight > 0.0 ) {\n\n\t\t\tcolor += specularColor( wo, wi, surf );\n\n\t\t}\n\n\t\tcolor *= sheenAlbedoScaling( wo, wi, surf );\n\t\tcolor += sheenColor( wo, wi, surf );\n\n\t}\n\n\tif( clearcoatWi.z >= 0.0 && clearcoatWeight > 0.0 ) {\n\n\t\tclearcoatColor( color, clearcoatWo, clearcoatWi, surf );\n\n\t}\n\n\treturn color;\n\n}\n\nfloat bsdfResult( vec3 wo, vec3 clearcoatWo, vec3 wi, vec3 clearcoatWi, SurfaceRec surf, out vec3 color ) {\n\n\tfloat diffuseWeight;\n\tfloat specularWeight;\n\tfloat transmissionWeight;\n\tfloat clearcoatWeight;\n\tgetLobeWeights( wo, clearcoatWo, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight );\n\n\tfloat specularPdf;\n\tcolor = bsdfColor( wo, clearcoatWo, wi, clearcoatWi, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight );\n\treturn bsdfPdf( wo, clearcoatWo, wi, clearcoatWi, surf, specularPdf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight );\n\n}\n\nSampleRec bsdfSample( vec3 wo, vec3 clearcoatWo, mat3 normalBasis, mat3 invBasis, mat3 clearcoatNormalBasis, mat3 clearcoatInvBasis, SurfaceRec surf ) {\n\n\tfloat diffuseWeight;\n\tfloat specularWeight;\n\tfloat transmissionWeight;\n\tfloat clearcoatWeight;\n\tgetLobeWeights( wo, clearcoatWo, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight );\n\n\tfloat pdf[4];\n\tpdf[0] = diffuseWeight;\n\tpdf[1] = specularWeight;\n\tpdf[2] = transmissionWeight;\n\tpdf[3] = clearcoatWeight;\n\n\tfloat cdf[4];\n\tcdf[0] = pdf[0];\n\tcdf[1] = pdf[1] + cdf[0];\n\tcdf[2] = pdf[2] + cdf[1];\n\tcdf[3] = pdf[3] + cdf[2];\n\n\tif( cdf[3] != 0.0 ) {\n\n\t\tfloat invMaxCdf = 1.0 / cdf[3];\n\t\tcdf[0] *= invMaxCdf;\n\t\tcdf[1] *= invMaxCdf;\n\t\tcdf[2] *= invMaxCdf;\n\t\tcdf[3] *= invMaxCdf;\n\n\t} else {\n\n\t\tcdf[0] = 1.0;\n\t\tcdf[1] = 0.0;\n\t\tcdf[2] = 0.0;\n\t\tcdf[3] = 0.0;\n\n\t}\n\n\tvec3 wi;\n\tvec3 clearcoatWi;\n\n\tfloat r = rand();\n\tif ( r <= cdf[0] ) {\n\n\t\twi = diffuseDirection( wo, surf );\n\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\n\n\t} else if ( r <= cdf[1] ) {\n\n\t\twi = specularDirection( wo, surf );\n\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\n\n\t} else if ( r <= cdf[2] ) {\n\n\t\twi = transmissionDirection( wo, surf );\n\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\n\n\t} else if ( r <= cdf[3] ) {\n\n\t\tclearcoatWi = clearcoatDirection( clearcoatWo, surf );\n\t\twi = normalize( invBasis * normalize( clearcoatNormalBasis * clearcoatWi ) );\n\n\t}\n\n\tSampleRec result;\n\tresult.pdf = bsdfPdf( wo, clearcoatWo, wi, clearcoatWi, surf, result.specularPdf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight );\n\tresult.color = bsdfColor( wo, clearcoatWo, wi, clearcoatWi, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight );\n\tresult.direction = wi;\n\tresult.clearcoatDirection = clearcoatWi;\n\n\treturn result;\n\n}\n`})),r.register("bmrjs",(function(e,n){t(e.exports,"shaderGGXFunctions",(()=>a));const a="\n// The GGX functions provide sampling and distribution information for normals as output so\n// in order to get probability of scatter direction the half vector must be computed and provided.\n// [0] https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n// [1] https://hal.archives-ouvertes.fr/hal-01509746/document\n// [2] http://jcgt.org/published/0007/04/01/\n// [4] http://jcgt.org/published/0003/02/03/\n\n// trowbridge-reitz === GGX === GTR\n\nvec3 ggxDirection( vec3 incidentDir, float roughnessX, float roughnessY, float random1, float random2 ) {\n\n\t// TODO: try GGXVNDF implementation from reference [2], here. Needs to update ggxDistribution\n\t// function below, as well\n\n\t// Implementation from reference [1]\n\t// stretch view\n\tvec3 V = normalize( vec3( roughnessX * incidentDir.x, roughnessY * incidentDir.y, incidentDir.z ) );\n\n\t// orthonormal basis\n\tvec3 T1 = ( V.z < 0.9999 ) ? normalize( cross( V, vec3( 0.0, 0.0, 1.0 ) ) ) : vec3( 1.0, 0.0, 0.0 );\n\tvec3 T2 = cross( T1, V );\n\n\t// sample point with polar coordinates (r, phi)\n\tfloat a = 1.0 / ( 1.0 + V.z );\n\tfloat r = sqrt( random1 );\n\tfloat phi = ( random2 < a ) ? random2 / a * PI : PI + ( random2 - a ) / ( 1.0 - a ) * PI;\n\tfloat P1 = r * cos( phi );\n\tfloat P2 = r * sin( phi ) * ( ( random2 < a ) ? 1.0 : V.z );\n\n\t// compute normal\n\tvec3 N = P1 * T1 + P2 * T2 + V * sqrt( max( 0.0, 1.0 - P1 * P1 - P2 * P2 ) );\n\n\t// unstretch\n\tN = normalize( vec3( roughnessX * N.x, roughnessY * N.y, max( 0.0, N.z ) ) );\n\n\treturn N;\n\n}\n\n// Below are PDF and related functions for use in a Monte Carlo path tracer\n// as specified in Appendix B of the following paper\n// See equation (2) from reference [2]\nfloat ggxLamda( float theta, float roughness ) {\n\n\tfloat tanTheta = tan( theta );\n\tfloat tanTheta2 = tanTheta * tanTheta;\n\tfloat alpha2 = roughness * roughness;\n\n\tfloat numerator = - 1.0 + sqrt( 1.0 + alpha2 * tanTheta2 );\n\treturn numerator / 2.0;\n\n}\n\n// See equation (2) from reference [2]\nfloat ggxShadowMaskG1( float theta, float roughness ) {\n\n\treturn 1.0 / ( 1.0 + ggxLamda( theta, roughness ) );\n\n}\n\n// See equation (125) from reference [4]\nfloat ggxShadowMaskG2( vec3 wi, vec3 wo, float roughness ) {\n\n\tfloat incidentTheta = acos( wi.z );\n\tfloat scatterTheta = acos( wo.z );\n\treturn 1.0 / ( 1.0 + ggxLamda( incidentTheta, roughness ) + ggxLamda( scatterTheta, roughness ) );\n\n}\n\nfloat ggxDistribution( vec3 halfVector, float roughness ) {\n\n\t// See equation (33) from reference [0]\n\tfloat a2 = roughness * roughness;\n\ta2 = max( EPSILON, a2 );\n\tfloat cosTheta = halfVector.z;\n\tfloat cosTheta4 = pow( cosTheta, 4.0 );\n\n\tif ( cosTheta == 0.0 ) return 0.0;\n\n\tfloat theta = acosSafe( halfVector.z );\n\tfloat tanTheta = tan( theta );\n\tfloat tanTheta2 = pow( tanTheta, 2.0 );\n\n\tfloat denom = PI * cosTheta4 * pow( a2 + tanTheta2, 2.0 );\n\treturn ( a2 / denom );\n\n\t// See equation (1) from reference [2]\n\t// const { x, y, z } = halfVector;\n\t// const a2 = roughness * roughness;\n\t// const mult = x * x / a2 + y * y / a2 + z * z;\n\t// const mult2 = mult * mult;\n\n\t// return 1.0 / Math.PI * a2 * mult2;\n\n}\n\n// See equation (3) from reference [2]\nfloat ggxPDF( vec3 wi, vec3 halfVector, float roughness ) {\n\n\tfloat incidentTheta = acos( wi.z );\n\tfloat D = ggxDistribution( halfVector, roughness );\n\tfloat G1 = ggxShadowMaskG1( incidentTheta, roughness );\n\n\treturn D * G1 * max( 0.0, dot( wi, halfVector ) ) / wi.z;\n\n}\n"})),r.register("bQHTv",(function(e,n){t(e.exports,"shaderSheenFunctions",(()=>a));const a="\n\n// See equation (2) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\nfloat velvetD( float cosThetaH, float roughness ) {\n\n\tfloat alpha = max( roughness, 0.07 );\n\talpha = alpha * alpha;\n\n\tfloat invAlpha = 1.0 / alpha;\n\n\tfloat sqrCosThetaH = cosThetaH * cosThetaH;\n\tfloat sinThetaH = max( 1.0 - sqrCosThetaH, 0.001 );\n\n\treturn ( 2.0 + invAlpha ) * pow( sinThetaH, 0.5 * invAlpha ) / ( 2.0 * PI );\n\n}\n\nfloat velvetParamsInterpolate( int i, float oneMinusAlphaSquared ) {\n\n\tconst float p0[5] = float[5]( 25.3245, 3.32435, 0.16801, -1.27393, -4.85967 );\n\tconst float p1[5] = float[5]( 21.5473, 3.82987, 0.19823, -1.97760, -4.32054 );\n\n\treturn mix( p1[i], p0[i], oneMinusAlphaSquared );\n\n}\n\nfloat velvetL( float x, float alpha ) {\n\n\tfloat oneMinusAlpha = 1.0 - alpha;\n\tfloat oneMinusAlphaSquared = oneMinusAlpha * oneMinusAlpha;\n\n\tfloat a = velvetParamsInterpolate( 0, oneMinusAlphaSquared );\n\tfloat b = velvetParamsInterpolate( 1, oneMinusAlphaSquared );\n\tfloat c = velvetParamsInterpolate( 2, oneMinusAlphaSquared );\n\tfloat d = velvetParamsInterpolate( 3, oneMinusAlphaSquared );\n\tfloat e = velvetParamsInterpolate( 4, oneMinusAlphaSquared );\n\n\treturn a / ( 1.0 + b * pow( abs( x ), c ) ) + d * x + e;\n\n}\n\n// See equation (3) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\nfloat velvetLambda( float cosTheta, float alpha ) {\n\n\treturn abs( cosTheta ) < 0.5 ? exp( velvetL( cosTheta, alpha ) ) : exp( 2.0 * velvetL( 0.5, alpha ) - velvetL( 1.0 - cosTheta, alpha ) );\n\n}\n\n// See Section 3, Shadowing Term, in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\nfloat velvetG( float cosThetaO, float cosThetaI, float roughness ) {\n\n\tfloat alpha = max( roughness, 0.07 );\n\talpha = alpha * alpha;\n\n\treturn 1.0 / ( 1.0 + velvetLambda( cosThetaO, alpha ) + velvetLambda( cosThetaI, alpha ) );\n\n}\n\nfloat directionalAlbedoSheen( float cosTheta, float alpha ) {\n\n\tcosTheta = saturate( cosTheta );\n\n\tfloat c = 1.0 - cosTheta;\n\tfloat c3 = c * c * c;\n\n\treturn 0.65584461 * c3 + 1.0 / ( 4.16526551 + exp( -7.97291361 * sqrt( alpha ) + 6.33516894 ) );\n\n}\n\nfloat sheenAlbedoScaling( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\tfloat alpha = max( surf.sheenRoughness, 0.07 );\n\talpha = alpha * alpha;\n\n\tfloat maxSheenColor = max( max( surf.sheenColor.r, surf.sheenColor.g ), surf.sheenColor.b );\n\n\tfloat eWo = directionalAlbedoSheen( saturateCos( wo.z ), alpha );\n\tfloat eWi = directionalAlbedoSheen( saturateCos( wi.z ), alpha );\n\n\treturn min( 1.0 - maxSheenColor * eWo, 1.0 - maxSheenColor * eWi );\n\n}\n\n// See Section 5, Layering, in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\nfloat sheenAlbedoScaling( vec3 wo, SurfaceRec surf ) {\n\n\tfloat alpha = max( surf.sheenRoughness, 0.07 );\n\talpha = alpha * alpha;\n\n\tfloat maxSheenColor = max( max( surf.sheenColor.r, surf.sheenColor.g ), surf.sheenColor.b );\n\n\tfloat eWo = directionalAlbedoSheen( saturateCos( wo.z ), alpha );\n\n\treturn 1.0 - maxSheenColor * eWo;\n\n}\n\n"})),r.register("6wwLz",(function(e,n){t(e.exports,"shaderIridescenceFunctions",(()=>a));const a="\n\n// XYZ to sRGB color space\nconst mat3 XYZ_TO_REC709 = mat3(\n\t 3.2404542, -0.9692660,  0.0556434,\n\t-1.5371385,  1.8760108, -0.2040259,\n\t-0.4985314,  0.0415560,  1.0572252\n);\n\nvec3 fresnel0ToIor( vec3 fresnel0 ) {\n\n\tvec3 sqrtF0 = sqrt( fresnel0 );\n\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\n}\n\n// Conversion FO/IOR\nvec3 iorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\n\treturn square( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\n}\n\n// ior is a value between 1.0 and 3.0. 1.0 is air interface\nfloat iorToFresnel0( float transmittedIor, float incidentIor ) {\n\n\treturn square( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ) );\n\n}\n\n// Fresnel equations for dielectric/dielectric interfaces. See https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html\nvec3 evalSensitivity( float OPD, vec3 shift ) {\n\n\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\n\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\n\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - square( phase ) * var );\n\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * square( phase ) );\n\txyz /= 1.0685e-7;\n\n\tvec3 srgb = XYZ_TO_REC709 * xyz;\n\treturn srgb;\n\n}\n\n// See Section 4. Analytic Spectral Integration, A Practical Extension to Microfacet Theory for the Modeling of Varying Iridescence, https://hal.archives-ouvertes.fr/hal-01518344/document\nvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\n\tvec3 I;\n\n\t// Force iridescenceIor -> outsideIOR when thinFilmThickness -> 0.0\n\tfloat iridescenceIor = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\n\t// Evaluate the cosTheta on the base layer (Snell law)\n\tfloat sinTheta2Sq = square( outsideIOR / iridescenceIor ) * ( 1.0 - square( cosTheta1 ) );\n\n\t// Handle TIR:\n\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\tif ( cosTheta2Sq < 0.0 ) {\n\n\t\treturn vec3( 1.0 );\n\n\t}\n\n\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\n\t// First interface\n\tfloat R0 = iorToFresnel0( iridescenceIor, outsideIOR );\n\tfloat R12 = schlickFresnel( cosTheta1, R0 );\n\tfloat R21 = R12;\n\tfloat T121 = 1.0 - R12;\n\tfloat phi12 = 0.0;\n\tif ( iridescenceIor < outsideIOR ) {\n\n\t\tphi12 = PI;\n\n\t}\n\tfloat phi21 = PI - phi12;\n\n\t// Second interface\n\tvec3 baseIOR = fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) ); // guard against 1.0\n\tvec3 R1 = iorToFresnel0( baseIOR, iridescenceIor );\n\tvec3 R23 = schlickFresnel( cosTheta2, R1 );\n\tvec3 phi23 = vec3( 0.0 );\n\tif ( baseIOR[0] < iridescenceIor ) {\n\n\t\tphi23[ 0 ] = PI;\n\n\t}\n\tif ( baseIOR[1] < iridescenceIor ) {\n\n\t\tphi23[ 1 ] = PI;\n\n\t}\n\tif ( baseIOR[2] < iridescenceIor ) {\n\n\t\tphi23[ 2 ] = PI;\n\n\t}\n\n\t// Phase shift\n\tfloat OPD = 2.0 * iridescenceIor * thinFilmThickness * cosTheta2;\n\tvec3 phi = vec3( phi21 ) + phi23;\n\n\t// Compound terms\n\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\tvec3 r123 = sqrt( R123 );\n\tvec3 Rs = square( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\n\t// Reflectance term for m = 0 (DC term amplitude)\n\tvec3 C0 = R12 + Rs;\n\tI = C0;\n\n\t// Reflectance term for m > 0 (pairs of diracs)\n\tvec3 Cm = Rs - T121;\n\tfor ( int m = 1; m <= 2; ++ m )\n\t{\n\t\tCm *= r123;\n\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\tI += Cm * Sm;\n\t}\n\n\t// Since out of gamut colors might be produced, negative color values are clamped to 0.\n\treturn max( I, vec3( 0.0 ) );\n}\n\n"})),r.register("1RTaa",(function(e,n){t(e.exports,"shaderEnvMapSampling",(()=>a));const a="\n\nvec3 sampleEquirectEnvMapColor( vec3 direction, sampler2D map ) {\n\n\treturn texture2D( map, equirectDirectionToUv( direction ) ).rgb;\n\n}\n\nfloat envMapDirectionPdf( vec3 direction ) {\n\n\tvec2 uv = equirectDirectionToUv( direction );\n\tfloat theta = uv.y * PI;\n\tfloat sinTheta = sin( theta );\n\tif ( sinTheta == 0.0 ) {\n\n\t\treturn 0.0;\n\n\t}\n\n\treturn 1.0 / ( 2.0 * PI * PI * sinTheta );\n\n}\n\nfloat envMapSample( vec3 direction, EquirectHdrInfo info, out vec3 color ) {\n\n\tvec2 uv = equirectDirectionToUv( direction );\n\tcolor = texture2D( info.map, uv ).rgb;\n\n\tfloat totalSum = texture2D( info.totalSum, vec2( 0.0 ) ).r;\n\tfloat lum = colorToLuminance( color );\n\tivec2 resolution = textureSize( info.map, 0 );\n\tfloat pdf = lum / totalSum;\n\n\treturn float( resolution.x * resolution.y ) * pdf * envMapDirectionPdf( direction );\n\n}\n\nfloat randomEnvMapSample( EquirectHdrInfo info, out vec3 color, out vec3 direction ) {\n\n\t// sample env map cdf\n\tvec2 r = rand2();\n\tfloat v = texture2D( info.marginalWeights, vec2( r.x, 0.0 ) ).x;\n\tfloat u = texture2D( info.conditionalWeights, vec2( r.y, v ) ).x;\n\tvec2 uv = vec2( u, v );\n\n\tvec3 derivedDirection = equirectUvToDirection( uv );\n\tdirection = derivedDirection;\n\tcolor = texture2D( info.map, uv ).rgb;\n\n\tfloat totalSum = texture2D( info.totalSum, vec2( 0.0 ) ).r;\n\tfloat lum = colorToLuminance( color );\n\tivec2 resolution = textureSize( info.map, 0 );\n\tfloat pdf = lum / totalSum;\n\n\treturn float( resolution.x * resolution.y ) * pdf * envMapDirectionPdf( direction );\n\n}\n\n"})),r.register("22srR",(function(e,n){t(e.exports,"shaderLightSampling",(()=>a));const a="\n\nstruct LightSampleRec {\n\tbool hit;\n\tfloat dist;\n\tvec3 direction;\n\tfloat pdf;\n\tvec3 emission;\n};\n\nLightSampleRec lightsClosestHit( sampler2D lights, uint lightCount, vec3 rayOrigin, vec3 rayDirection ) {\n\n\tLightSampleRec lightSampleRec;\n\tlightSampleRec.hit = false;\n\n\tuint l;\n\tfor ( l = 0u; l < lightCount; l++ ) {\n\n\t\tLight light = readLightInfo( lights, l );\n\n\t\tvec3 u = light.u;\n\t\tvec3 v = light.v;\n\n\t\t// check for backface\n\t\tvec3 normal = normalize( cross( u, v ) );\n\t\tif ( dot( normal, rayDirection ) < 0.0 ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tu *= 1.0 / dot(u, u);\n\t\tv *= 1.0 / dot(v, v);\n\n\t\tfloat dist;\n\t\tif ( intersectsRectangle( light.position, normal, u, v, rayOrigin, rayDirection, dist ) ) {\n\n\t\t\tif ( dist < lightSampleRec.dist || !lightSampleRec.hit ) {\n\n\t\t\t\tlightSampleRec.hit = true;\n\t\t\t\tlightSampleRec.dist = dist;\n\t\t\t\tfloat cosTheta = dot( rayDirection, normal );\n\t\t\t\tlightSampleRec.pdf = ( dist * dist ) / ( light.area * cosTheta );\n\t\t\t\tlightSampleRec.emission = light.color * light.intensity;\n\t\t\t\tlightSampleRec.direction = rayDirection;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn lightSampleRec;\n\n}\n\nLightSampleRec randomRectAreaLightSample( Light light, vec3 rayOrigin ) {\n\n\tLightSampleRec lightSampleRec;\n\tlightSampleRec.hit = true;\n\n\tlightSampleRec.emission = light.color * light.intensity;\n\n\tvec3 randomPos = light.position + light.u * ( rand() - 0.5 ) + light.v * ( rand() - 0.5 );\n\tvec3 toLight = randomPos - rayOrigin;\n\tfloat lightDistSq = dot( toLight, toLight );\n\tlightSampleRec.dist = length( toLight );\n\n\tvec3 direction = normalize( toLight );\n\tlightSampleRec.direction = direction;\n\n\tvec3 lightNormal = normalize( cross( light.u, light.v ) );\n\tlightSampleRec.pdf = lightDistSq / ( light.area * dot( direction, lightNormal ) );\n\n\treturn lightSampleRec;\n\n}\n\nLightSampleRec randomLightSample( sampler2D lights, uint lightCount, vec3 rayOrigin ) {\n\n\t// pick a random light\n\tuint l = uint( rand() * float( lightCount ) );\n\tLight light = readLightInfo( lights, l );\n\n\t// sample the light\n\treturn randomRectAreaLightSample( light, rayOrigin );\n\n}\n\n"})),r.register("iyhQ7",(function(e,n){t(e.exports,"PhysicalCameraUniform",(()=>i));var a=r("csrdQ");class i{constructor(){this.bokehSize=0,this.apertureBlades=0,this.apertureRotation=0,this.focusDistance=10,this.anamorphicRatio=1}updateFrom(t){t instanceof a.PhysicalCamera?(this.bokehSize=t.bokehSize,this.apertureBlades=t.apertureBlades,this.apertureRotation=t.apertureRotation,this.focusDistance=t.focusDistance,this.anamorphicRatio=t.anamorphicRatio):(this.bokehSize=0,this.apertureRotation=0,this.apertureBlades=0,this.focusDistance=10,this.anamorphicRatio=1)}}})),r.register("kAJM1",(function(e,n){t(e.exports,"EquirectHdrInfoUniform",(()=>s));var a=r("ilwiq");function i(t,e,n=0,a=t.length){let r=0,i=a;for(;r<i;){const a=~~(.5*i+.5*r);t[n+a]<e?r=a+1:i=a}return r}function o(t,e,n){return.2126*t+.7152*e+.0722*n}class s{constructor(){const t=new a.DataTexture;t.type=a.FloatType,t.format=a.RedFormat,t.minFilter=a.LinearFilter,t.magFilter=a.LinearFilter,t.generateMipmaps=!1;const e=new a.DataTexture;e.type=a.FloatType,e.format=a.RedFormat,e.minFilter=a.LinearFilter,e.magFilter=a.LinearFilter,e.generateMipmaps=!1;const n=new a.DataTexture;n.type=a.FloatType,n.format=a.RedFormat,n.minFilter=a.LinearFilter,n.magFilter=a.LinearFilter,n.generateMipmaps=!1,this.marginalWeights=t,this.conditionalWeights=e,this.totalSum=n,this.map=null}dispose(){this.marginalWeights.dispose(),this.conditionalWeights.dispose(),this.totalSum.dispose(),this.map&&this.map.dispose()}updateFrom(t){const e=function(t){const e=t.clone();e.source=new a.Source({...e.image});const{width:n,height:r,data:i}=e.image;let o=i;if(e.type===a.HalfFloatType){o=new Float32Array(i.length);for(const t in i)o[t]=a.DataUtils.fromHalfFloat(i[t]);e.image.data=o,e.type=a.FloatType}if(e.flipY){const t=o;o=o.slice();for(let e=0;e<r;e++)for(let a=0;a<n;a++){const i=4*(e*n+a),s=4*((r-e-1)*n+a);o[s+0]=t[i+0],o[s+1]=t[i+1],o[s+2]=t[i+2],o[s+3]=t[i+3]}e.flipY=!1,e.image.data=o}return e}(t);e.wrapS=a.RepeatWrapping,e.wrapT=a.RepeatWrapping;const{width:n,height:r,data:s}=e.image,l=new Float32Array(n*r),c=new Float32Array(n*r),h=new Float32Array(r),u=new Float32Array(r);let f=0,m=0;for(let t=0;t<r;t++){let e=0;for(let a=0;a<n;a++){const r=t*n+a,i=o(s[4*r+0],s[4*r+1],s[4*r+2]);e+=i,f+=i,l[r]=i,c[r]=e}if(0!==e)for(let a=t*n,r=t*n+n;a<r;a++)l[a]/=e,c[a]/=e;m+=e,h[t]=e,u[t]=m}if(0!==m)for(let t=0,e=h.length;t<e;t++)h[t]/=m,u[t]/=m;const d=new Float32Array(r),p=new Float32Array(n*r);for(let t=0;t<r;t++){const e=i(u,(t+1)/r);d[t]=e/r}for(let t=0;t<r;t++)for(let e=0;e<n;e++){const a=t*n+e,r=i(c,(e+1)/n,t*n,n);p[a]=r/n}this.dispose();const{marginalWeights:g,conditionalWeights:v,totalSum:y}=this;g.image={width:r,height:1,data:d},g.needsUpdate=!0,v.image={width:n,height:r,data:p},v.needsUpdate=!0,y.image={width:1,height:1,data:new Float32Array([f])},y.needsUpdate=!0,this.map=e}}})),r.register("jNveS",(function(e,n){t(e.exports,"LightsTexture",(()=>i));var a=r("ilwiq");class i extends a.DataTexture{constructor(){super(new Float32Array(4),1,1),this.format=a.RGBAFormat,this.type=a.FloatType,this.wrapS=a.ClampToEdgeWrapping,this.wrapT=a.ClampToEdgeWrapping,this.generateMipmaps=!1}updateFrom(t){let e=0;const n=4*t.length,r=Math.ceil(Math.sqrt(n));this.image.width!==r&&(this.dispose(),this.image.data=new Float32Array(r*r*4),this.image.width=r,this.image.height=r);const i=this.image.data,o=new a.Vector3,s=new a.Vector3,l=new a.Quaternion;for(let n=0,a=t.length;n<a;n++){const a=t[n];a.getWorldPosition(s),i[e++]=s.x,i[e++]=s.y,i[e++]=s.z,e++,i[e++]=a.color.r,i[e++]=a.color.g,i[e++]=a.color.b,i[e++]=a.intensity,a.getWorldQuaternion(l),o.set(a.width,0,0).applyQuaternion(l),i[e++]=o.x,i[e++]=o.y,i[e++]=o.z,e++,s.set(0,a.height,0).applyQuaternion(l),i[e++]=s.x,i[e++]=s.y,i[e++]=s.z,i[e++]=o.cross(s).length()}this.needsUpdate=!0}}})),r.register("891vQ",(function(e,n){t(e.exports,"RGBELoader",(()=>i));var a=r("ilwiq");class i extends a.DataTextureLoader{constructor(t){super(t),this.type=a.HalfFloatType}parse(t){const e=function(t,e){switch(t){case 1:console.error("THREE.RGBELoader Read Error: "+(e||""));break;case 2:console.error("THREE.RGBELoader Write Error: "+(e||""));break;case 3:console.error("THREE.RGBELoader Bad File Format: "+(e||""));break;default:console.error("THREE.RGBELoader: Error: "+(e||""))}return-1},n=function(t,e,n){e=e||1024;let a=t.pos,r=-1,i=0,o="",s=String.fromCharCode.apply(null,new Uint16Array(t.subarray(a,a+128)));for(;0>(r=s.indexOf("\n"))&&i<e&&a<t.byteLength;)o+=s,i+=s.length,a+=128,s+=String.fromCharCode.apply(null,new Uint16Array(t.subarray(a,a+128)));return-1<r&&(!1!==n&&(t.pos+=i+r+1),o+s.slice(0,r))},r=function(t,e,n,a){const r=t[e+3],i=Math.pow(2,r-128)/255;n[a+0]=t[e+0]*i,n[a+1]=t[e+1]*i,n[a+2]=t[e+2]*i,n[a+3]=1},i=function(t,e,n,r){const i=t[e+3],o=Math.pow(2,i-128)/255;n[r+0]=a.DataUtils.toHalfFloat(Math.min(t[e+0]*o,65504)),n[r+1]=a.DataUtils.toHalfFloat(Math.min(t[e+1]*o,65504)),n[r+2]=a.DataUtils.toHalfFloat(Math.min(t[e+2]*o,65504)),n[r+3]=a.DataUtils.toHalfFloat(1)},o=new Uint8Array(t);o.pos=0;const s=function(t){const a=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,r=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,i=/^\s*FORMAT=(\S+)\s*$/,o=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,s={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let l,c;if(t.pos>=t.byteLength||!(l=n(t)))return e(1,"no header found");if(!(c=l.match(/^#\?(\S+)/)))return e(3,"bad initial token");for(s.valid|=1,s.programtype=c[1],s.string+=l+"\n";l=n(t),!1!==l;)if(s.string+=l+"\n","#"!==l.charAt(0)){if((c=l.match(a))&&(s.gamma=parseFloat(c[1])),(c=l.match(r))&&(s.exposure=parseFloat(c[1])),(c=l.match(i))&&(s.valid|=2,s.format=c[1]),(c=l.match(o))&&(s.valid|=4,s.height=parseInt(c[1],10),s.width=parseInt(c[2],10)),2&s.valid&&4&s.valid)break}else s.comments+=l+"\n";return 2&s.valid?4&s.valid?s:e(3,"missing image size specifier"):e(3,"missing format specifier")}(o);if(-1!==s){const t=s.width,n=s.height,l=function(t,n,a){const r=n;if(r<8||r>32767||2!==t[0]||2!==t[1]||128&t[2])return new Uint8Array(t);if(r!==(t[2]<<8|t[3]))return e(3,"wrong scanline width");const i=new Uint8Array(4*n*a);if(!i.length)return e(4,"unable to allocate buffer space");let o=0,s=0;const l=4*r,c=new Uint8Array(4),h=new Uint8Array(l);let u=a;for(;u>0&&s<t.byteLength;){if(s+4>t.byteLength)return e(1);if(c[0]=t[s++],c[1]=t[s++],c[2]=t[s++],c[3]=t[s++],2!=c[0]||2!=c[1]||(c[2]<<8|c[3])!=r)return e(3,"bad rgbe scanline format");let n,a=0;for(;a<l&&s<t.byteLength;){n=t[s++];const r=n>128;if(r&&(n-=128),0===n||a+n>l)return e(3,"bad scanline data");if(r){const e=t[s++];for(let t=0;t<n;t++)h[a++]=e}else h.set(t.subarray(s,s+n),a),a+=n,s+=n}const f=r;for(let t=0;t<f;t++){let e=0;i[o]=h[t+e],e+=r,i[o+1]=h[t+e],e+=r,i[o+2]=h[t+e],e+=r,i[o+3]=h[t+e],o+=4}u--}return i}(o.subarray(o.pos),t,n);if(-1!==l){let e,o,c;switch(this.type){case a.FloatType:c=l.length/4;const t=new Float32Array(4*c);for(let e=0;e<c;e++)r(l,4*e,t,4*e);e=t,o=a.FloatType;break;case a.HalfFloatType:c=l.length/4;const n=new Uint16Array(4*c);for(let t=0;t<c;t++)i(l,4*t,n,4*t);e=n,o=a.HalfFloatType;break;default:console.error("THREE.RGBELoader: unsupported type: ",this.type)}return{width:t,height:n,data:e,header:s.string,gamma:s.gamma,exposure:s.exposure,type:o}}}return null}setDataType(t){return this.type=t,this}load(t,e,n,r){return super.load(t,(function(t,n){switch(t.type){case a.FloatType:case a.HalfFloatType:t.encoding=a.LinearEncoding,t.minFilter=a.LinearFilter,t.magFilter=a.LinearFilter,t.generateMipmaps=!1,t.flipY=!0}e&&e(t,n)}),n,r)}}}));
//# sourceMappingURL=areaLight.71edbf0a.js.map
